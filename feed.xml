<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX Open Source Project</title>
    <description>Focus on cross-platform development using c language</description>
    <link>http://www.tboox.org/</link>
    <atom:link href="http://www.tboox.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 02 Jan 2020 09:08:01 +0800</pubDate>
    <lastBuildDate>Thu, 02 Jan 2020 09:08:01 +0800</lastBuildDate>
    <generator>Jekyll v3.1.0</generator>
    
      <item>
        <title>TBOOX开源工程2019总结和明年规划</title>
        <description>&lt;p&gt;今年一年总体还是有不少收获的，尤其是&lt;a href=&quot;https://xmake.io&quot;&gt;xmake&lt;/a&gt;，今年大部分时间都花在这个项目上面，总共发了5个大版本，大小特性改动不下百处，新增1000多次commit，处理issues超过300个。&lt;/p&gt;

&lt;p&gt;不过&lt;a href=&quot;https://github.com/tboox/tbox&quot;&gt;tbox&lt;/a&gt;也陆陆续续做了一些更新，还是有不少改进的地方。&lt;/p&gt;

&lt;p&gt;关于今年整体的项目进展，这边也做个简单的总结吧，这里主要总结一些比较大的特性改进，一些零散的小模块改动就不一一列举了。&lt;/p&gt;

&lt;h3 id=&quot;完成了远程包依赖管理&quot;&gt;完成了远程包依赖管理&lt;/h3&gt;

&lt;p&gt;这也是是今年最大的收获了，毕竟陆陆续续耗时了将近一年时间，虽然还有不少需要改进的地方，自建的包仓库也还不是很丰富，明年我会继续去完善它。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;libuv master&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ffmpeg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;zlib 1.20.*&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_requires&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tbox &amp;gt;1.6.1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;optional&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_packages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;libuv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ffmpeg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;tbox&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;zlib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/index/package_arch.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;新增vsxmake生成插件&quot;&gt;新增vsxmake生成插件&lt;/h3&gt;

&lt;p&gt;新版本xmake重新实现了一个vs工程的生成插件（非常感谢@OpportunityLiu的贡献），跟之前的生成vs的插件处理模式上有很大的不同，原先生成的vs工程是把所有源文件展开后，转交给vs来处理编译。&lt;/p&gt;

&lt;p&gt;但是像rules和自定义脚本这种是没法支持的，因为xmake的rules里面用了很多的on_build此类自定义脚本，无法展开，所以像qt， wdk此类的项目就没法支持导出到vs里面进行编译了。&lt;/p&gt;

&lt;p&gt;因此，为了解决这个问题，新版本的vs生成插件通过在vs下直接调用xmake命令，去执行编译操作，并且对intellsence和定义跳转，还有断点调试也做了支持。&lt;/p&gt;

&lt;p&gt;具体使用方式跟老版本类似：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;vsxmake2010|vsxmake2013|vsxmake2015|..] -m &lt;span class=&quot;s2&quot;&gt;&quot;debug;release&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/manual/qt_vs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;上线了新版的文档站点&quot;&gt;上线了新版的文档站点&lt;/h3&gt;

&lt;p&gt;由于之前的docute文档站仅支持单页markdown，随着文档的不断增多，维护起来越来越臃肿，因此今年我整体切到了docsify来管理。&lt;/p&gt;

&lt;p&gt;文档站点：&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;https://xmake.io/#/zh-cn/&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/xmake-docs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;xmake日活用户翻了10倍&quot;&gt;xmake日活用户翻了10倍&lt;/h3&gt;

&lt;p&gt;其实也就只有50多个日活用户（比较惨 = =），不过相比去年每天仅仅只有5个独立用户在使用xmake来构建，今年算是有了不少起色，借助github traffics的粗略统计，每天有超过50个用户在使用xmake来构建自己的项目，每天构建的项目数超过100个。&lt;/p&gt;

&lt;p&gt;明年继续，哈哈~&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/xmake-stats-2019.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;github-star数也增长了不少&quot;&gt;github star数也增长了不少&lt;/h3&gt;

&lt;p&gt;毕竟是冷门项目，受众很小，今年tbox和xmake都涨了1k多我已经知足了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/star-history-2019.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;一些使用了xmake的开源项目&quot;&gt;一些使用了xmake的开源项目&lt;/h3&gt;

&lt;p&gt;今年也有了一些知名的第三方开源项目使用了xmake来维护构建，主要有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/acl-dev/acl&quot;&gt;libacl&lt;/a&gt;: An advanced C/C++ Network library&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/acl-dev/libfiber&quot;&gt;libfiber&lt;/a&gt;: The high performance coroutine library for Linux/FreeBSD/Windows, supporting select/poll/epoll/kqueue/iocp/windows GUI&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/idealvin/co&quot;&gt;co&lt;/a&gt;: An elegant and efficient C++ basic library for Linux, Windows and Mac.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/fasiondog/hikyuu&quot;&gt;hikyuu&lt;/a&gt;: Hikyuu Quant Framework 基于C++/Python的开源量化交易研究框架&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lc-ui/lcui.css&quot;&gt;LCUI.css&lt;/a&gt;: A UI component framework for building LCUI application.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/lc-soft/LC-Finder&quot;&gt;LC-Finder&lt;/a&gt;: A simple pciture resource manager, support tag search and thumbnail preview.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这里有个项目列表，里面是我收集到一些使用了xmake的项目：&lt;a href=&quot;https://github.com/xmake-io/awesome-xmake#projects&quot;&gt;https://github.com/xmake-io/awesome-xmake#projects&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;明年xmake相关的一些计划&quot;&gt;明年xmake相关的一些计划&lt;/h3&gt;

&lt;p&gt;明年的重点主要是在远程编译和分布式编译上，为此最近我正在改进tbox的协程支持，并且正在对xmake的lua协程做进一步封装，实现对pipe，socket和process的统一调度支持，为后续的远程编译做准备。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;实现跨平台的远程编译&lt;/li&gt;
  &lt;li&gt;实现跨平台的分布式编译&lt;/li&gt;
  &lt;li&gt;继续完善xmake与编辑器/IDE的集成&lt;/li&gt;
  &lt;li&gt;完善远程依赖包管理，自建仓库增加更多常用依赖包&lt;/li&gt;
  &lt;li&gt;继续封装lua的io协程调度模块，实现对pipe，socket和process的统一调度支持&lt;/li&gt;
  &lt;li&gt;提供对xcode工程的生成插件&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;tbox的一些特性改进&quot;&gt;tbox的一些特性改进&lt;/h3&gt;

&lt;p&gt;今年没花太多时间在tbox上面，总共也就发了一个版本，大部分特性改动主要还是服务于xmake，例如：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;添加stdfile接口去读写stdin, stdout和stderr。&lt;/li&gt;
  &lt;li&gt;添加对进程和线程的cpu亲缘性设置和获取&lt;/li&gt;
  &lt;li&gt;添加filelock文件锁跨平台api接口&lt;/li&gt;
  &lt;li&gt;添加匿名管道，命名管道支持&lt;/li&gt;
  &lt;li&gt;改进字符集编码转换，以及增加对ANSI编码的支持&lt;/li&gt;
  &lt;li&gt;改进原子操作，并增加c11风格原子接口&lt;/li&gt;
  &lt;li&gt;新增进程输出重定向到管道&lt;/li&gt;
  &lt;li&gt;针对协程栈使用虚拟内存&lt;/li&gt;
  &lt;li&gt;改进基于openssl/mbedtls的https访问&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不过明年我会进一步改进和实现协程、网络相关的模块，提供更多实用的基础功能。&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/12/31/tboox-now-and-future/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/12/31/tboox-now-and-future/</guid>
        
        <category>tboox</category>
        
        <category>tbox</category>
        
        <category>xmake</category>
        
        
        <category>tboox</category>
        
      </item>
    
      <item>
        <title>xmake v2.2.9 released, Add experimental support for c++ 20 modules</title>
        <description>&lt;p&gt;There are not many new features in this version. It mainly supports c++ 20 modules experimentally. Currently it supports the clang/msvc compiler. In addition, it improves a lot of user experience and improves some stability.&lt;/p&gt;

&lt;p&gt;In addition, this version adds socket.io support and scheduling support for coroutine io to prepare for remote compilation of the next version and subsequent distributed compilation.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;Project Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/&quot;&gt;Official Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;introduction-of-new-features&quot;&gt;Introduction of new features&lt;/h2&gt;

&lt;h3 id=&quot;c20-modules&quot;&gt;c++20 modules&lt;/h3&gt;

&lt;p&gt;c++ modules have been officially included in the c++20 draft, and msvc and clang have been basically implemented on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019 /p1103r3.pdf&quot;&gt;modules-ts&lt;/a&gt; Support, as c++20’s footsteps are getting closer and closer to us, xmake has also begun to support c++modules in advance.&lt;/p&gt;

&lt;p&gt;At present xmake has fully supported the implementation of the modules-ts of msvc/clang. For gcc, since its cxx-modules branch is still under development, it has not officially entered the master. I have read the changelog inside, and the related flags are still in the process. Constantly changing, I feel that it has not stabilized, so I have not supported it yet.&lt;/p&gt;

&lt;p&gt;For more information about xmake’s progress on c++modules: &lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;https://github.com/xmake-io/xmake/pull/569&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;hello-module&quot;&gt;Hello Module&lt;/h4&gt;

&lt;p&gt;I will not talk about the introduction of c++modules. This is mainly about how to build a c++modules project under xmake. Let’s look at a simple example:&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.mpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above is a description of the xmake.lua that supports building c++modules files, where &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.mpp&lt;/code&gt; is the module file:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Main.cpp is the main program that uses the hello module:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello module!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we execute xmake to build this program:&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake
[0%]: ccache compiling.release src/hello.mpp
[50%]: ccache compiling.release src/main.cpp
[100%]: linking.release hello
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake will handle all the details logic internally, for developers, just add the module file &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; as the source file.&lt;/p&gt;

&lt;h4 id=&quot;module-interface-file&quot;&gt;Module Interface File&lt;/h4&gt;

&lt;p&gt;The above mentioned &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; is the module interface file name recommended by xmake. In fact, the default suffix names of the compiler files are not uniform. clang is &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;, while msvc is &lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;, which is very unfriendly for writing a unified module project across compilers.
Therefore, reference is made to the recommendation method in &lt;a href=&quot;https://build2.org/doc/modules-cppcon2017.pdf&quot;&gt;build2&lt;/a&gt;, and the unified &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; suffix is used to standardize the command of the module project interface under xmake.&lt;/p&gt;

&lt;p&gt;Of course, this also supports xmake’s recommended naming scheme. For suffixes such as &lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;, xmake is also fully compatible and can be added directly to &lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&quot;other-examples&quot;&gt;Other examples&lt;/h4&gt;

&lt;p&gt;There are also a lot of engineering examples related to c++modules built into the xmake project. Interested students can refer to the following: &lt;a href=&quot;https://github.com/xmake-io/xmake/tree/dev/tests/projects/c%2B%2B/modules&quot;&gt;c++module examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;set_toolchain-interface-changes&quot;&gt;set_toolchain interface changes&lt;/h3&gt;

&lt;p&gt;The set_toolchain interface is mainly used to set different compilation toolchains for the target. Versions before 2.2.9 actually have two interfaces: add_tools and set_tools to handle the same thing, but the two interfaces are named and used in accordance with the specifications. It is very consistent, so some adjustments and changes have been made, and the new set_toolchain interface is used to better set up the toolchain.&lt;/p&gt;

&lt;p&gt;For source files added by &lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;*.c&quot;)&lt;/code&gt;, by default, they will call the system’s most suitable compilation tool to compile, or modify them manually by using the &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --cc=clang&lt;/code&gt; command, but these are all Globally affects all target targets.&lt;/p&gt;

&lt;p&gt;If there are special requirements, you need to specify different compilers, linkers, or compilers of a specific version for a specific target under the current project. At this time, this interface can be used, for example:&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_toolchain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;$(projectdir)/tools/bin/clang-5.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above description only makes special settings for the compiler of the test2 target, using a specific clang-5.0 compiler to compile test2, and test1 still uses the default settings.&lt;/p&gt;

&lt;p&gt;For some compiler file names that are irregular and cause xmake to fail to recognize and process them as known compiler names, we can also add a tool name hint, for example:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;`lua
set_toolchain(&quot;cc&quot;, &quot;gcc@$(projectdir)/tools/bin/mipscc.exe&quot;)
&lt;/code&gt; `&lt;/p&gt;

&lt;p&gt;The above description sets mipscc.exe as the C compiler, and prompts xmake to compile as a parameter passing method for gcc.&lt;/p&gt;

&lt;h3 id=&quot;socket-io&quot;&gt;socket io&lt;/h3&gt;

&lt;p&gt;This interface has been initially implemented, supports lua coroutine io scheduling, and achieves high concurrent io reading and writing (it will also support process and pipe scheduling support at the same time). It is currently mainly used for xmake itself and is used for subsequent To prepare for remote compilation and distributed compilation, users are not allowed to use it for the time being, but it will be released after subsequent improvements. Users can also make some service programs through socket io in their plugins.&lt;/p&gt;

&lt;p&gt;However, there are not many scenarios that users may use. After all, xmake is only a build tool, and rarely allows users to do io communication by themselves.&lt;/p&gt;

&lt;h2 id=&quot;changelog&quot;&gt;Changelog&lt;/h2&gt;

&lt;h3 id=&quot;new-features&quot;&gt;New features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;#569&lt;/a&gt;: Add c++ modules build rules&lt;/li&gt;
  &lt;li&gt;Add &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake project -k xmakefile&lt;/code&gt; generator&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/620&quot;&gt;620&lt;/a&gt;: Add global &lt;code class=&quot;highlighter-rouge&quot;&gt;~/.xmakerc.lua&lt;/code&gt; for all projects.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/593&quot;&gt;593&lt;/a&gt;: Add &lt;code class=&quot;highlighter-rouge&quot;&gt;core.base.socket&lt;/code&gt; module.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;change&quot;&gt;Change&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/563&quot;&gt;#563&lt;/a&gt;: Separate build rules for specific language files from action/build&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/570&quot;&gt;#570&lt;/a&gt;: Add &lt;code class=&quot;highlighter-rouge&quot;&gt;qt.widgetapp&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt; rules&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/576&quot;&gt;#576&lt;/a&gt;: Uses &lt;code class=&quot;highlighter-rouge&quot;&gt;set_toolchain&lt;/code&gt; instead of &lt;code class=&quot;highlighter-rouge&quot;&gt;add_tools&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;set_tools&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Improve &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt; action&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/589&quot;&gt;#589&lt;/a&gt;: Improve the default build jobs number to optimize build speed&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/598&quot;&gt;#598&lt;/a&gt;: Improve find_package to support .tbd libraries on macOS&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/615&quot;&gt;#615&lt;/a&gt;: Support to install and use other archs and ios conan packages&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/629&quot;&gt;#629&lt;/a&gt;: Improve hash.uuid and implement uuid v4&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/639&quot;&gt;#639&lt;/a&gt;: Improve to parse argument options to support -jN&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs-fixed&quot;&gt;Bugs fixed&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/567&quot;&gt;#567&lt;/a&gt;: Fix out of memory for serialize&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/566&quot;&gt;#566&lt;/a&gt;: Fix link order problem with remote packages&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/565&quot;&gt;#565&lt;/a&gt;: Fix run path for vcpkg packages&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/597&quot;&gt;#597&lt;/a&gt;: Fix run &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake require&lt;/code&gt; command too slowly&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/634&quot;&gt;#634&lt;/a&gt;: Fix mode.coverage rule and check flags&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 21 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/2019/12/21/xmake-update-v2.2.9/</link>
        <guid isPermaLink="true">http://www.tboox.org/2019/12/21/xmake-update-v2.2.9/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>C/C++</category>
        
        <category>c++20</category>
        
        <category>ts-modules</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake v2.2.9 发布, 新增c++20 modules的实验性支持</title>
        <description>&lt;p&gt;这个版本没啥太大新特性，主要对c++20 modules进行了实验性支持，目前支持clang/msvc编译器，除此之外改进了不少使用体验，并且提高了一些稳定性。&lt;/p&gt;

&lt;p&gt;另外，这个版本新增了socket.io支持以及对应协程io的调度支持，为下个版本的远程编译，以及后续的分布式编译做准备。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;新特性介绍&quot;&gt;新特性介绍&lt;/h2&gt;

&lt;h3 id=&quot;c20-modules&quot;&gt;c++20 modules&lt;/h3&gt;

&lt;p&gt;c++ modules已经正式纳入了c++20草案，msvc和clang也已经基本实现了对&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&quot;&gt;modules-ts&lt;/a&gt;的支持，随着c++20的脚步离我们越来越近，xmake也开始对c++modules提前做好了支持。&lt;/p&gt;

&lt;p&gt;目前xmake已经完全支持了msvc/clang的modules-ts构建实现，而对于gcc，由于它的cxx-modules分支还在开发中，还没有正式进入master，我看了下里面的changelog，相关flags还在不断变动，感觉还没稳定下来，因此这里暂时还没对其进行支持。&lt;/p&gt;

&lt;p&gt;关于xmake对c++modules的相关进展见：&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;https://github.com/xmake-io/xmake/pull/569&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;hello-module&quot;&gt;Hello Module&lt;/h4&gt;

&lt;p&gt;关于c++modules的相关介绍我就不多说了，这边主要还是介绍下xmake下如何去构建c++modules项目，我们先来看一个简单的例子：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.mpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是一个支持构建c++modules文件的xmake.lua描述，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;hello.mpp&lt;/code&gt;就是模块文件：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而main.cpp是使用了hello模块的主程序：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello module!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来我们执行xmake来构建下这个程序吧：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake 
[  0%]: ccache compiling.release src/hello.mpp
[ 50%]: ccache compiling.release src/main.cpp
[100%]: linking.release hello
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是非常简单，xmake内部会去处理所有细节逻辑，对于开发者而言，仅仅是添加了模块文件&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;作为源文件而已。&lt;/p&gt;

&lt;h4 id=&quot;模块接口文件&quot;&gt;模块接口文件&lt;/h4&gt;

&lt;p&gt;上文所述的&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;是xmake推荐的模块接口文件命名，其实各家编译器对于模块文件的默认后缀名都是不统一的，clang下是&lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;，而msvc下是&lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;，这对于编写跨编译器统一的模块项目是非常不友好的，
因此这里参考了&lt;a href=&quot;https://build2.org/doc/modules-cppcon2017.pdf&quot;&gt;build2&lt;/a&gt;里面的推荐方式，采用统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;后缀，来规范xmake下模块项目接口的命令。&lt;/p&gt;

&lt;p&gt;当然，这也支持xmake推荐命名方式，而对于&lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;等后缀名，xmake也是完全兼容支持的，也可以直接添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;中去。&lt;/p&gt;

&lt;h4 id=&quot;其他例子&quot;&gt;其他例子&lt;/h4&gt;

&lt;p&gt;xmake项目下还内置了不少跟c++modules相关的工程examples，有兴趣的同学可以参考下：&lt;a href=&quot;https://github.com/xmake-io/xmake/tree/dev/tests/projects/c%2B%2B/modules&quot;&gt;c++module examples&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;set_toolchain接口改动&quot;&gt;set_toolchain接口改动&lt;/h3&gt;

&lt;p&gt;set_toolchain这个接口主要用于针对target设置不同的编译工具链，2.2.9之前的版本其实有&lt;code class=&quot;highlighter-rouge&quot;&gt;add_tools&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;set_tools&lt;/code&gt;两个接口来处理相同的事情，不过这两接口命名和使用上和规范不是很一致，因此做了些调整改动，用这个set_toolchain新接口更好的设置工具链。&lt;/p&gt;

&lt;p&gt;对于&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;*.c&quot;)&lt;/code&gt;添加的源码文件，默认都是会调用系统最匹配的编译工具去编译，或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --cc=clang&lt;/code&gt;命令手动去修改，不过这些都是全局影响所有target目标的。&lt;/p&gt;

&lt;p&gt;如果有些特殊需求，需要对当前工程下某个特定的target目标单独指定不同的编译器、链接器或者特定版本的编译器，这个时候此接口就可以排上用途了，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_toolchain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;$(projectdir)/tools/bin/clang-5.0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述描述仅对test2目标的编译器进行特殊设置，使用特定的clang-5.0编译器来编译test2，而test1还是使用默认设置。&lt;/p&gt;

&lt;p&gt;对于一些编译器文件名不规则，导致xmake无法正常识别处理为已知的编译器名的情况下，我们也可以加一个工具名提示，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set_toolchain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;gcc@$(projectdir)/tools/bin/mipscc.exe&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述描述设置mipscc.exe作为c编译器，并且提示xmake作为gcc的传参处理方式进行编译。&lt;/p&gt;

&lt;h3 id=&quot;socket-io&quot;&gt;socket io&lt;/h3&gt;

&lt;p&gt;这块的接口初步已经实现，支持lua协程的io调度，实现高并发的io读写（后期还会同时支持进程、pipe的调度支持），目前主要用于xmake自身的使用，用于为后续的远程编译和分布式编译做准备，所以暂时不开放用户自己使用，不过等后续完善后，会开放出来，用户也可以在自己的插件里面通过socket io做一些服务程序。&lt;/p&gt;

&lt;p&gt;不过可能用户用到的场景不是很多，毕竟xmake只是个构建工具，很少会让用户自己去做io通信。&lt;/p&gt;

&lt;h2 id=&quot;更新内容&quot;&gt;更新内容&lt;/h2&gt;

&lt;h3 id=&quot;新特性&quot;&gt;新特性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;#569&lt;/a&gt;: 增加对c++模块的实验性支持&lt;/li&gt;
  &lt;li&gt;添加&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake project -k xmakefile&lt;/code&gt;生成器&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/620&quot;&gt;620&lt;/a&gt;: 添加全局&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.xmakerc.lua&lt;/code&gt;配置文件，对所有本地工程生效.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/593&quot;&gt;593&lt;/a&gt;: 添加&lt;code class=&quot;highlighter-rouge&quot;&gt;core.base.socket&lt;/code&gt;模块，为下一步远程编译和分布式编译做准备。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;改进&quot;&gt;改进&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/563&quot;&gt;#563&lt;/a&gt;: 重构构建逻辑，将特定语言的构建抽离到独立的rules中去&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/570&quot;&gt;#570&lt;/a&gt;: 改进Qt构建，将&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.application&lt;/code&gt;拆分成&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.widgetapp&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;两个构建规则&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/576&quot;&gt;#576&lt;/a&gt;: 使用&lt;code class=&quot;highlighter-rouge&quot;&gt;set_toolchain&lt;/code&gt;替代&lt;code class=&quot;highlighter-rouge&quot;&gt;add_tools&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;set_tools&lt;/code&gt;，解决老接口使用歧义，提供更加易理解的设置方式&lt;/li&gt;
  &lt;li&gt;改进&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;创建模板工程&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/589&quot;&gt;#589&lt;/a&gt;: 改进默认的构建任务数，充分利用cpu core来提速整体编译速度&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/598&quot;&gt;#598&lt;/a&gt;: 改进&lt;code class=&quot;highlighter-rouge&quot;&gt;find_package&lt;/code&gt;支持在macOS上对.tbd系统库文件的查找&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/615&quot;&gt;#615&lt;/a&gt;: 支持安装和使用其他arch和ios的conan包&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/629&quot;&gt;#629&lt;/a&gt;: 改进hash.uuid并且实现uuid v4&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/639&quot;&gt;#639&lt;/a&gt;: 改进参数解析器支持&lt;code class=&quot;highlighter-rouge&quot;&gt;-jN&lt;/code&gt;风格传参&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;bugs修复&quot;&gt;Bugs修复&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/567&quot;&gt;#567&lt;/a&gt;: 修复序列化对象时候出现的内存溢出问题&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/566&quot;&gt;#566&lt;/a&gt;: 修复安装远程依赖的链接顺序问题&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/565&quot;&gt;#565&lt;/a&gt;: 修复vcpkg包的运行PATH设置问题&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/597&quot;&gt;#597&lt;/a&gt;: 修复xmake require安装包时间过长问题&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake/issues/634&quot;&gt;#634&lt;/a&gt;: 修复mode.coverage构建规则，并且改进flags检测&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 21 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/12/21/xmake-update-v2.2.9/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/12/21/xmake-update-v2.2.9/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>C/C++</category>
        
        <category>c++20</category>
        
        <category>ts-modules</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通10：多个子工程目标的依赖配置</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解下，如果在一个项目中维护和生成多个目标文件的生成，以及它们之间的依赖关系设置。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;target到底是什么&quot;&gt;target到底是什么？&lt;/h3&gt;

&lt;p&gt;xmake的概念定义里，一个独立的项目工程可能会有多个子工程组织在一起，每个子工程对应只能生成一个唯一的目标文件，例如：可执行程序，静态库或者动态库等。&lt;/p&gt;

&lt;p&gt;而这里所说的每个子工程就是xmake里面所说的&lt;code class=&quot;highlighter-rouge&quot;&gt;target&lt;/code&gt;，字面意思就是&lt;code class=&quot;highlighter-rouge&quot;&gt;目标子工程&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;因此每个子工程，我们都可以通过新增一个target在xmake.lua里面维护，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test1/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test2/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面我们就定义了两个独立的子工程目标，编译时候会生成两个互不依赖的可执行文件。&lt;/p&gt;

&lt;h3 id=&quot;从根域继承全局设置&quot;&gt;从根域继承全局设置&lt;/h3&gt;

&lt;p&gt;暂时先不谈target间的依赖问题，如果我们有许多通用设置，每个target下都得设置一遍，那会非常冗余，也不好维护。&lt;/p&gt;

&lt;p&gt;因此，我们可以把这些配置移到target域的外面，也就是根作用域中去设置，这样对当前xmake.lua以及所有子xmake.lua中的target都会生效，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;tbox&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;lib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;include&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test1/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test2/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;    
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如这两target都需要链接tbox库，放置在外层根域设置，test1和test2都能加上对应links。&lt;/p&gt;

&lt;h3 id=&quot;目标间的依赖设置&quot;&gt;目标间的依赖设置&lt;/h3&gt;

&lt;p&gt;那如果某个target需要用到另外一个tatget生成的静态库，应该怎么配置呢？&lt;/p&gt;

&lt;p&gt;一种方式就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_linkdirs&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;add_links&lt;/code&gt;手动指定对应target最后生成的目录库所在目录，然后把链接加上。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;FOO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo/inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(buildir)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;FOO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo/inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;$(buildir)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;FOO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上述配置中，test1和test2都会用到libfoo库，并且需要获取到libfoo库的头文件路径，库路径和链接，并且在使用过程中还需要额外设置&lt;code class=&quot;highlighter-rouge&quot;&gt;-DFOO&lt;/code&gt;宏定义开关才行。&lt;/p&gt;

&lt;p&gt;看上去没啥，其实这么写有两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;test目标和另外两个库目标之间是有编译顺序依赖的，如果test先编译就会提示链接库找不到&lt;/li&gt;
  &lt;li&gt;配置太过繁琐不好维护，test1和test2有很多冗余配置&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;那有没有更加简单可靠的配置方式呢，其实我们只需要&lt;code class=&quot;highlighter-rouge&quot;&gt;add_deps&lt;/code&gt;来对target间配置上依赖关系即可。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;FOO&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo/inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_deps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_deps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;foo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;对比下，test1和test2的配置，是不是精简了好多？仅仅通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_deps(&quot;foo&quot;)&lt;/code&gt;就继承了libfoo的所有导出设置：linkdirs, links, includedirs以及defines&lt;/p&gt;

&lt;p&gt;其中target自身生成的库默认就会自动导出链接设置，而includedirs和defines通过设置public属性，我们也将它们标记为导出，这样可以被test目标继承到。&lt;/p&gt;

&lt;p&gt;并且，现在有了依赖关系，xmake在编译的时候，会自动处理这些target之间的编译顺序，保证不会出现链接的时候，libfoo库还没有生成的问题。&lt;/p&gt;

&lt;h3 id=&quot;依赖继承的进一步解析&quot;&gt;依赖继承的进一步解析&lt;/h3&gt;

&lt;h4 id=&quot;级联依赖继承&quot;&gt;级联依赖继承&lt;/h4&gt;

&lt;p&gt;根据上文所说，target会自动继承依赖目标中的配置和属性，不需要额外调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add_links&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;add_linkdirs&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rpathdirs&lt;/code&gt;等接口去关联依赖目标了。&lt;/p&gt;

&lt;p&gt;并且继承关系是支持级联的，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;library1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;inc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 默认私有头文件目录不会被继承&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;inc1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;-- 此处的头文件相关目录也会被继承&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;library2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;static&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_deps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;library1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_deps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;library2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的配置中，test依赖library2，然后library2又依赖library1，那么通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_deps&lt;/code&gt;仅仅添加library2的依赖，test就可以完整继承整个依赖链上的所有导出设置。&lt;/p&gt;

&lt;h4 id=&quot;禁用默认的继承行为&quot;&gt;禁用默认的继承行为&lt;/h4&gt;

&lt;p&gt;那如果我们不想继承依赖target的任何配置，如何操作呢？&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_deps&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;dep1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;dep2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;inherit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过显式设置inherit配置，来告诉xmake，这两个依赖的配置是否需要被继承，如果不设置，默认就是启用继承的。&lt;/p&gt;

&lt;h4 id=&quot;可继承的导出属性详解&quot;&gt;可继承的导出属性详解&lt;/h4&gt;

&lt;p&gt;上文，我们还通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;add_includedirs(&quot;inc1&quot;, {public = true})&lt;/code&gt;, 设置public为true, 将includedirs的设置公开给其他依赖的子target继承。&lt;/p&gt;

&lt;p&gt;目前对于target的编译链接flags相关接口设置，都是支持继承属性的，可以人为控制是否需要导出给其他target来依赖继承，目前支持的属性有：&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;属性&lt;/th&gt;
      &lt;th&gt;描述&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;private&lt;/td&gt;
      &lt;td&gt;默认设置，作为当前target的私有配置，不会被依赖的其他target所继承&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;public&lt;/td&gt;
      &lt;td&gt;公有配置，当前target，依赖的子target都会被设置&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;interface&lt;/td&gt;
      &lt;td&gt;接口设置，仅被依赖的子target所继承设置，当前target不参与&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;这个其实参考借鉴了cmake的设计，目前xmake中只要跟target相关的所有编译链接设置接口，都是支持可见性导出的，例如：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_includedirs&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;add_defines&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;add_cflags&lt;/code&gt;等等。&lt;/p&gt;

&lt;p&gt;关于这块的详细信息，可以看下：https://github.com/xmake-io/xmake/issues/368&lt;/p&gt;

</description>
        <pubDate>Fri, 13 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/12/13/quickstart-10-target-deps/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/12/13/quickstart-10-target-deps/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>交叉编译</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通9：交叉编译详解</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;除了win, linux, macOS平台，以及android, ios等移动端平台的内建构建支持，xmake也支持对各种其他工具链的交叉编译支持，本文我们将会详细介绍下如何使用xmake进行交叉编译。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;交叉编译工具链简介&quot;&gt;交叉编译工具链简介&lt;/h3&gt;

&lt;p&gt;通常，如果我们需要在当前pc环境编译生成其他设备上才能运行的目标文件时候，就需要通过对应的交叉编译工具链来编译生成它们，比如在win/macos上编译linux的程序，或者在linux上编译其他嵌入式设备的目标文件等。&lt;/p&gt;

&lt;p&gt;通常的交叉编译工具链都是基于gcc/clang的，大都具有类似如下的结构：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/home/toolchains_sdkdir
   - bin
       - arm-linux-armeabi-gcc
       - arm-linux-armeabi-ld
       - ...
   - lib
       - libxxx.a
   - include
       - xxx.h
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;每个工具链都有对应的include/lib目录，用于放置一些系统库和头文件，例如libc, stdc++等，而bin目录下放置的就是编译工具链一系列工具。例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;arm-linux-armeabi-ar
arm-linux-armeabi-as
arm-linux-armeabi-c++
arm-linux-armeabi-cpp
arm-linux-armeabi-g++
arm-linux-armeabi-gcc
arm-linux-armeabi-ld
arm-linux-armeabi-nm
arm-linux-armeabi-strip
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;arm-linux-armeabi-&lt;/code&gt;前缀就是cross，通过用来标示目标平台和架构，主要用于跟主机自身的gcc/clang进行区分。&lt;/p&gt;

&lt;p&gt;里面的gcc/g++就是c/c++的编译器，通常也可以作为链接器使用，链接的时候内部会去调用ld来链接，并且自动追加一些c++库。
cpp是预处理器，as是汇编器，ar用于生成静态库，strip用于裁剪掉一些符号信息，使得目标程序会更加的小。nm用于查看导出符号列表。&lt;/p&gt;

&lt;h3 id=&quot;自动探测和编译&quot;&gt;自动探测和编译&lt;/h3&gt;

&lt;p&gt;如果我们的交叉编译工具链是上文的结构，xmake会自动检测识别这个sdk的结构，提取里面的cross，以及include/lib路径位置，用户通常不需要做额外的参数设置，只需要配置好sdk根目录就可以编译了，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p cross --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/toolchains_sdkdir
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-p cross&lt;/code&gt;用于指定当前的平台是交叉编译平台，&lt;code class=&quot;highlighter-rouge&quot;&gt;--sdk=&lt;/code&gt;用于指定交叉工具链的根目录。&lt;/p&gt;

&lt;p&gt;注：我们也可以指定&lt;code class=&quot;highlighter-rouge&quot;&gt;-p linux&lt;/code&gt;平台来配置交叉编译，效果是一样的，唯一的区别是额外标识了linux平台名，方便xmake.lua里面通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat(&quot;linux&quot;)&lt;/code&gt;来判断平台。&lt;/p&gt;

&lt;p&gt;这个时候，xmake会去自动探测gcc等编译器的前缀名cross：&lt;code class=&quot;highlighter-rouge&quot;&gt;arm-linux-armeabi-&lt;/code&gt;，并且编译的时候，也会自动加上&lt;code class=&quot;highlighter-rouge&quot;&gt;链接库&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;头文件&lt;/code&gt;的搜索选项，例如：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-I/home/toolchains_sdkdir/include 
-L/home/toolchains_sdkdir/lib
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些都是xmake自动处理的，不需要手动配置他们。&lt;/p&gt;

&lt;h3 id=&quot;手动配置编译&quot;&gt;手动配置编译&lt;/h3&gt;

&lt;p&gt;如果上面的自动检测对某些工具链，还无法完全通过编译，就需要用户自己手动设置一些交叉编译相关的配置参数，来调整适应这些特殊的工具链了，下面我会逐一讲解如何配置。&lt;/p&gt;

&lt;h4 id=&quot;设置工具链bin目录&quot;&gt;设置工具链bin目录&lt;/h4&gt;

&lt;p&gt;对于不规则工具链目录结构，靠单纯地&lt;a href=&quot;https://xmake.io/#/zh-cn/guide/configuration?id=-sdk&quot;&gt;–sdk&lt;/a&gt;选项设置，没法完全检测通过的情况下，可以通过这个选项继续附加设置工具链的bin目录位置。&lt;/p&gt;

&lt;p&gt;例如：一些特殊的交叉工具链的，编译器bin目录，并不在  &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/toolchains_sdkdir/bin&lt;/code&gt;  这个位置，而是独立到了  &lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/opt/bin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;这个时候，我们可以在设置了sdk参数的基础上追加bin目录的参数设置，来调整工具链的bin目录。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/toolchains_sdkdir --bin&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/opt/bin
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;设置交叉工具链工具前缀&quot;&gt;设置交叉工具链工具前缀&lt;/h4&gt;

&lt;p&gt;像aarch64-linux-android-这种，通常如果你配置了–sdk或者–bin的情况下，xmake会去自动检测的，不需要自己手动设置。&lt;/p&gt;

&lt;p&gt;但是对于一些极特殊的工具链，一个目录下同时有多个cross前缀的工具bin混在一起的情况，你需要手动设置这个配置，来区分到底需要选用哪个bin。&lt;/p&gt;

&lt;p&gt;例如，toolchains的bin目录下同时存在两个不同的编译器：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/opt/bin
  - armv7-linux-gcc 
  - aarch64-linux-gcc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们现在想要选用armv7的版本，那么我们可以追加&lt;code class=&quot;highlighter-rouge&quot;&gt;--cross=&lt;/code&gt;配置编译工具前缀名，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/toolsdk --bin&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/bin --cross&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;设置cc编译器&quot;&gt;设置c/c++编译器&lt;/h4&gt;

&lt;p&gt;如果还要继续细分选择编译器，则继续追加相关编译器选项，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/user/toolsdk --cc&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-clang --cxx&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-clang++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当然，我们也可以指定编译器全路径。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--cc&lt;/code&gt;用于指定c编译器名，&lt;code class=&quot;highlighter-rouge&quot;&gt;--cxx&lt;/code&gt;用于指定c++编译器名。&lt;/p&gt;

&lt;p&gt;注：如果存在CC/CXX环境变量的话，会优先使用当前环境变量中指定的值。&lt;/p&gt;

&lt;p&gt;如果指定的编译器名不是那些xmake内置可识别的名字（带有gcc, clang等字样），那么编译器工具检测就会失败。&lt;/p&gt;

&lt;p&gt;这个时候我们可以通过：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake f --cxx&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;clang++@/home/xxx/c++mips.exe
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置c++mips.exe编译器作为类clang++的使用方式来编译。&lt;/p&gt;

&lt;p&gt;也就是说，在指定编译器为&lt;code class=&quot;highlighter-rouge&quot;&gt;c++mips.exe&lt;/code&gt;的同时，告诉xmake，它跟clang++用法和参数选项基本相同。&lt;/p&gt;

&lt;h4 id=&quot;设置cc连接器&quot;&gt;设置c/c++连接器&lt;/h4&gt;

&lt;p&gt;如果还要继续细分选择链接器，则继续追加相关链接器选项，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/user/toolsdk --ld&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-clang++ --sh&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-clang++ --ar&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;armv7-linux-ar
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;ld指定可执行程序链接器，sh指定共享库程序链接器，ar指定生成静态库的归档器。&lt;/p&gt;

&lt;p&gt;注：如果存在LD/SH/AR环境变量的话，会优先使用当前环境变量中指定的值。&lt;/p&gt;

&lt;h4 id=&quot;设置头文件和库搜索目录&quot;&gt;设置头文件和库搜索目录&lt;/h4&gt;

&lt;p&gt;如果sdk里面还有额外的其他include/lib目录不在标准的结构中，导致交叉编译找不到库和头文件，那么我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--includedirs&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;--linkdirs&lt;/code&gt;来追加搜索路径，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--links&lt;/code&gt;添加额外的链接库。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/toolsdk --includedirs&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/toolsdk/xxx/include --linkdirs&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/toolsdk/xxx/lib --links&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;pthread
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：如果要指定多个搜索目录，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;来分割，也就是不同主机平台的路径分隔符，linux/macos下用&lt;code class=&quot;highlighter-rouge&quot;&gt;:&lt;/code&gt;，win下用&lt;code class=&quot;highlighter-rouge&quot;&gt;;&lt;/code&gt;。&lt;/p&gt;

&lt;h4 id=&quot;设置编译和链接选项&quot;&gt;设置编译和链接选项&lt;/h4&gt;

&lt;p&gt;我们也可以根据实际情况通过&lt;code class=&quot;highlighter-rouge&quot;&gt;--cflags&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--cxxflags&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;--ldflags&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;--shflags&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;--arflags&lt;/code&gt;额外配置一些编译和链接选项。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cflags: 指定c编译参数&lt;/li&gt;
  &lt;li&gt;cxxflags：指定c++编译参数&lt;/li&gt;
  &lt;li&gt;cxflags: 指定c/c++编译参数&lt;/li&gt;
  &lt;li&gt;asflags: 指定汇编器编译参数&lt;/li&gt;
  &lt;li&gt;ldflags: 指定可执行程序链接参数&lt;/li&gt;
  &lt;li&gt;shflags: 指定动态库程序链接参数&lt;/li&gt;
  &lt;li&gt;arflags: 指定静态库的生成参数&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/toolsdk --cflags&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-DTEST -I/xxx/xxx&quot;&lt;/span&gt; --ldflags&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-lpthread&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;mingw工具链&quot;&gt;mingw工具链&lt;/h3&gt;

&lt;p&gt;使用mingw工具链编译，其实也是交叉编译，但是由于这个比较常用，xmake专门增加了一个mingw的平台来快速处理使用mingw工具链的编译。&lt;/p&gt;

&lt;p&gt;因此，xmake对mingw的工具链检测会更加完善，在macos下，基本上连sdk路径都不需要配置，也能直接检测到，只需要切到mingw平台编译即可。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p mingw
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake -v
configure
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    ld &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++
    ndk_stdcxx &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
    &lt;/span&gt;plat &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; mingw
    mingw &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /usr/local/opt/mingw-w64
    buildir &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; build
    arch &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x86_64
    xcode &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /Applications/Xcode.app
    mode &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; release
    cxx &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc
    cross &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x86_64-w64-mingw32-
    theme &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; default
    kind &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; static
    ccache &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
    &lt;/span&gt;host &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; macosx
    clean &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;true
    &lt;/span&gt;bin &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; /usr/local/opt/mingw-w64/bin
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.release src/main.cpp
/usr/local/bin/ccache /usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-gcc -c -fvisibility&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hidden -O3 -m64 -o build/.objs/test/mingw/x86_64/release/src/main.cpp.obj src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release test.exe
/usr/local/opt/mingw-w64/bin/x86_64-w64-mingw32-g++ -o build/mingw/x86_64/release/test.exe build/.objs/test/mingw/x86_64/release/src/main.cpp.obj -s -fvisibility&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;hidden -m64
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这里我们追加了&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;参数，看了下详细的编译命令和检测到的mingw工具链配置值，其中cross被自动检测为：&lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64-w64-mingw32-&lt;/code&gt;，bin目录也被自动检测到了，还有编译器和链接器也是。&lt;/p&gt;

&lt;p&gt;尽管在linux/win上还没法自动检测到sdk路径，我们也可以手动指定sdk路径，需要注意的是，xmake为mingw专门提供了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;--mingw=&lt;/code&gt;参数用来指定mingw的工具链根目录，其效果跟&lt;code class=&quot;highlighter-rouge&quot;&gt;--sdk=&lt;/code&gt;是一样的，但是它可以作为全局配置被设置。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --mingw&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/mingwsdk
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p mingw
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake g/global&lt;/code&gt;命令设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--mingw&lt;/code&gt;根目录到全局配置后，之后每次编译和切换编译平台，就不用额外指定mingw工具链路径了，方便使用。&lt;/p&gt;

&lt;p&gt;另外，其他的工具链配置参数用法，跟上文描述的没什么区别，像&lt;code class=&quot;highlighter-rouge&quot;&gt;--cross&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;--bin=&lt;/code&gt;等都可以根据实际的环境需要，自己控制是否需要额外追加配置来适配自己的mingw工具链。&lt;/p&gt;

&lt;h3 id=&quot;项目描述设置&quot;&gt;项目描述设置&lt;/h3&gt;

&lt;h4 id=&quot;set_toolchain&quot;&gt;set_toolchain&lt;/h4&gt;

&lt;p&gt;如果觉得每次通过命令行配置比较繁琐，有些配置可以通过在xmake.lua预先配置好，来简化命令配置，比如编译器的指定，就可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set_toolchain&lt;/code&gt;来对每个target单独设置。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_toolchain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;clang&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_toolchain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ld&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;clang++&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;强制test目标的编译器和链接器使用clang编译器，或者指定交叉编译工具链中的编译器名或者路径。&lt;/p&gt;

&lt;h4 id=&quot;set_config&quot;&gt;set_config&lt;/h4&gt;

&lt;p&gt;我们也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set_config&lt;/code&gt;来设置在&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f/config&lt;/code&gt;命令中的每个配置参数的默认值，这是个全局api，对每个target都会生效。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cflags&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-DTEST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sdk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/home/xxx/tooksdk&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;cc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;gcc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ld&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;g++&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;不过，我们还是可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --name=value&lt;/code&gt;的方式，去修改xmake.lua中的默认配置。&lt;/p&gt;

&lt;h3 id=&quot;自定义编译平台&quot;&gt;自定义编译平台&lt;/h3&gt;

&lt;p&gt;如果某个交叉工具链编译后目标程序有对应的平台需要指定，并且需要在xmake.lua里面根据不同的交叉编译平台，还需要配置一些额外的编译参数，那么上文的&lt;code class=&quot;highlighter-rouge&quot;&gt;-p cross&lt;/code&gt;设置就不能满足需求了。&lt;/p&gt;

&lt;p&gt;其实，&lt;code class=&quot;highlighter-rouge&quot;&gt;-p/--plat=&lt;/code&gt;参数也可以设置为其他自定义的值，只需要跟&lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat&lt;/code&gt;保持对应关系就可以，所有非内置平台名，都会默认采用交叉编译模式，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p myplat --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/arm-xxx-gcc/
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们传入了myplat自定义平台名，作为当前交叉工具链的编译平台，然后xmake.lua里面我们对这个平台，配置下对应的设置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;myplat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过这种方式，xmake就可以很方便的扩展处理各种编译平台，用户可以自己扩展支持freebsd, netbsd, sunos等其他各种平台的交叉编译。&lt;/p&gt;

&lt;p&gt;我摘录一段之前移植libuv写的交叉编译的配置，直观感受下：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- for gragonfly/freebsd/netbsd/openbsd platform&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;gragonfly&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;freebsd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;netbsd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;openbsd&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/bsd-ifaddrs.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/freebsd.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/kqueue.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/posix-hrtime.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_headerfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;(include/uv-bsd.h)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt; 

&lt;span class=&quot;c1&quot;&gt;-- for sunos platform&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sunos&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
     &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/no-proctitle.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/unix/sunos.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;__EXTENSIONS_&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;_XOPEN_SOURCE=600&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_headerfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;(include/uv-sunos.h)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，我们就可以切换这些平台来编译：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;gragonfly|freebsd|netbsd|openbsd|sunos] --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/arm-xxx-gcc/
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，内置的linux平台也是支持交叉编译的哦，如果不想配置其他平台名，统一作为linux平台来交叉编译，也是可以的。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p linux --sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local/arm-xxx-gcc/
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;--sdk=&lt;/code&gt;等参数，就会启用linux平台的交叉编译模式。&lt;/p&gt;
</description>
        <pubDate>Thu, 05 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/12/05/quickstart-9-cross-compile/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/12/05/quickstart-9-cross-compile/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>交叉编译</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通8：切换编译模式</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文我们会详细介绍下如何在项目构建过程中切换debug/release等常用构建模式，以及自定义其他编译模式。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;调试和发布模式&quot;&gt;调试和发布模式&lt;/h3&gt;

&lt;p&gt;通常，如果我们是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;命令创建的项目，会在xmake.lua里面自动添加一行编译规则的配置，如下：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules&lt;/code&gt;接口，我们默认添加了release和debug两个常用的内置规则，它们会在编译的时候附带上对应模式相关的一些编译flags，来开启优化用于发布或者调试编译。&lt;/p&gt;

&lt;p&gt;如果仅仅执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake&lt;/code&gt;命令，没有额外的配置，那么默认就会是release编译，等价于：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m release
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果我们要切换到debug编译模式，只需要：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m debug
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.debug src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.debug &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;-m/--mode=&lt;/code&gt;参数就是用来设置编译模式，会跟&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.release&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.debug&lt;/code&gt;这两个规则做关联。&lt;/p&gt;

&lt;p&gt;那么，他们是如何关联上的呢？我们可以先来看下这两个规则的内部实现：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;after_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;symbols&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;symbols&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;optimize&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;optimize&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;after_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;symbols&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;and&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;targetkind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;~=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;symbols&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;optimize&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;android&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;iphoneos&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;optimize&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;smallest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
                    &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;optimize&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;ow&quot;&gt;not&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;strip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;strip&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，在target被加载阶段，xmake会去判断用户对&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --mode=xxx&lt;/code&gt;的参数配置，如果通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is_mode()&lt;/code&gt;接口获取到是debug模式，那么会禁用相关优化并且启用符号输出。
而如果是release模式，那么会开启编译优化并且strip掉所有调试符号。&lt;/p&gt;

&lt;h3 id=&quot;定制化的模式配置&quot;&gt;定制化的模式配置&lt;/h3&gt;

&lt;p&gt;当然，内置的这两规则默认设置的这些编译配置，只能满足大部分场景的常规需求，如果用户想要在不同的编译模式下定制化一些个人的编译配置，那么需要自己在xmake.lua做判断。&lt;/p&gt;

&lt;p&gt;例如，我们想在release下也启用调试符号，那么只需要：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者额外增加一些编译flags：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fomit-frame-pointer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：如果用户自己的配置和&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.release&lt;/code&gt;内置的配置冲突，会优先使用用户的设置。&lt;/p&gt;

&lt;p&gt;当然，我们也可以完全不去通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules(&quot;mode.debug&quot;, &quot;mode.release&quot;)&lt;/code&gt;添加默认的配置规则，让用户完全自己控制模式配置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 如果当前编译模式是debug&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加DEBUG编译宏&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;DEBUG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 启用调试符号&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 禁用优化&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 如果是release或者profile模式&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 如果是release模式&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;-- 隐藏符号&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;-- strip所有符号&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

        &lt;span class=&quot;c1&quot;&gt;-- 忽略帧指针&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_cxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fomit-frame-pointer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_mxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fomit-frame-pointer&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 如果是profile模式&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;-- 启用调试符号&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;-- 添加扩展指令集&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_vectorexts&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sse2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;sse3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;ssse3&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mmx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;其他内置模式规则&quot;&gt;其他内置模式规则&lt;/h3&gt;

&lt;p&gt;通过上文的例子，我们看到除了debug/release模式，还加了个profile模式的配置判断，其实xmake也提供了对应的内置模式，还有哪些，我们具体来看下：&lt;/p&gt;

&lt;h4 id=&quot;modedebug&quot;&gt;mode.debug&lt;/h4&gt;

&lt;p&gt;为当前工程xmake.lua添加debug编译模式的配置规则，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以通过：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m debug&lt;/code&gt;来切换到此编译模式。&lt;/p&gt;

&lt;h4 id=&quot;moderelease&quot;&gt;mode.release&lt;/h4&gt;

&lt;p&gt;为当前工程xmake.lua添加release编译模式的配置规则，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以通过：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m release&lt;/code&gt;来切换到此编译模式。&lt;/p&gt;

&lt;h4 id=&quot;modecheck&quot;&gt;mode.check&lt;/h4&gt;

&lt;p&gt;为当前工程xmake.lua添加check编译模式的配置规则，一般用于内存检测，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.check&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;check&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fsanitize=address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-ftrapv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_mxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fsanitize=address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-ftrapv&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_ldflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-fsanitize=address&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以通过：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m check&lt;/code&gt;来切换到此编译模式。&lt;/p&gt;

&lt;h4 id=&quot;modeprofile&quot;&gt;mode.profile&lt;/h4&gt;

&lt;p&gt;为当前工程xmake.lua添加profile编译模式的配置规则，一般用于性能分析，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;profile&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-pg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_ldflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-pg&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以通过：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m profile&lt;/code&gt;来切换到此编译模式。&lt;/p&gt;

&lt;h4 id=&quot;modecoverage&quot;&gt;mode.coverage&lt;/h4&gt;

&lt;p&gt;为当前工程xmake.lua添加coverage编译模式的配置规则，一般用于覆盖分析，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.coverage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;相当于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;coverage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;--coverage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_mxflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;--coverage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_ldflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;--coverage&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们可以通过：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m coverage&lt;/code&gt;来切换到此编译模式。&lt;/p&gt;

&lt;p&gt;注：生成的gcno文件一般都是个obj所在目录对应的哦，因此需要从build目录下去找。&lt;/p&gt;

&lt;h3 id=&quot;扩展自己的编译模式&quot;&gt;扩展自己的编译模式&lt;/h3&gt;

&lt;p&gt;xmake的模式配置，并没有固定值，用户可以随意传入和配置，只要&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f -m/--mode=xxx&lt;/code&gt;传入的模式值和xmake.lua里面的&lt;code class=&quot;highlighter-rouge&quot;&gt;is_mode(&quot;xxx&quot;)&lt;/code&gt;能对应上就行。&lt;/p&gt;

&lt;p&gt;比如，我们设置了一个自己独有的编译模式&lt;code class=&quot;highlighter-rouge&quot;&gt;my_mode&lt;/code&gt;，可以直接在命令行配置切换；&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m my_mode
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.my_mode src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.my_mode &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后xmake.lua里面对相应的值进行判断即可：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;my_mode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ENABLE_MY_MODE&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用模式变量&quot;&gt;使用模式变量&lt;/h3&gt;

&lt;p&gt;我们也可以直接在配置值中传递模式变量&lt;code class=&quot;highlighter-rouge&quot;&gt;$(mode)&lt;/code&gt;，比如根据不同模式选择链接不同的库：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx_$(mode)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的配置，如果是调试模式编译就会选择链接：&lt;code class=&quot;highlighter-rouge&quot;&gt;libxxx_debug.a&lt;/code&gt;库，而release下就会链接&lt;code class=&quot;highlighter-rouge&quot;&gt;libxxx_release.a&lt;/code&gt;，当然，我们也可以设置到库搜索路径中，根据目录来选择对应的库。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;lib/$(mode)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另外，我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;get_config(&quot;mode&quot;)&lt;/code&gt;直接获取到传入的模式配置值，并且这几种获取方式，在自定义脚本也是同样有效的哦，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;on_load&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;get_config&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;),&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;$(mode)&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
</description>
        <pubDate>Thu, 05 Dec 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/12/05/quickstart-8-switch-build-mode/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/12/05/quickstart-8-switch-build-mode/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>编译模式</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通7：开发和构建Cuda程序</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文我们会详细介绍下如何通过xmake来构建cuda程序以及与c/c++程序混合编译。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;准备环境&quot;&gt;准备环境&lt;/h3&gt;

&lt;p&gt;首先，我们需要安装NVIDIA提供的Cuda Toolkit SDK工具，其相关说明以及安装文档，可参考官方文档：&lt;a href=&quot;http://docs.nvidia.com/cuda/index.html&quot;&gt;CUDA Toolkit Documentation&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;下载安装好Cuda SDK后，在macosx上会默认安装到&lt;code class=&quot;highlighter-rouge&quot;&gt;/Developer/NVIDIA/CUDA-x.x&lt;/code&gt;目录下，Windows上可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;CUDA_PATH&lt;/code&gt;的环境变量找到对应的SDK目录，而
Linux下默认会安装到&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/local/cuda&lt;/code&gt;目录下。&lt;/p&gt;

&lt;p&gt;通常，xmake都能自动检测到默认的cuda安装环境，并不需要做任何操作，只需要执行&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake&lt;/code&gt;命令就可以自动完成编译，当然如果找不到SDK，我们也可以手动指定Cuda SDK环境目录：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;xmake&lt;/span&gt;&lt;span class=&quot;kv&quot;&gt; f --cuda=/usr/local/cuda-9.1/ 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake g/global&lt;/code&gt;命令切到全局设置，避免每次切换编译模式都要重新配置一遍。&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;w&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;xmake&lt;/span&gt;&lt;span class=&quot;kv&quot;&gt; g --cuda=/usr/local/cuda-9.1/ 
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果想要测试xmake对当前cuda环境的探测支持，可以直接运行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake l detect.sdks.find_cuda
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
  linkdirs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;s2&quot;&gt;&quot;/Developer/NVIDIA/CUDA-10.2/lib/stubs&quot;&lt;/span&gt;,
    &lt;span class=&quot;s2&quot;&gt;&quot;/Developer/NVIDIA/CUDA-10.2/lib&quot;&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;,
  bindir &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/Developer/NVIDIA/CUDA-10.2/bin&quot;&lt;/span&gt;,
  sdkdir &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/Developer/NVIDIA/CUDA-10.2&quot;&lt;/span&gt;,
  includedirs &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
    &lt;span class=&quot;s2&quot;&gt;&quot;/Developer/NVIDIA/CUDA-10.2/include&quot;&lt;/span&gt; 
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;大家也可以帮忙贡献相关检测代码&lt;a href=&quot;https://github.com/xmake-io/xmake/blob/master/xmake/modules/detect/sdks/find_cuda.lua&quot;&gt;find_cuda.lua&lt;/a&gt;来改进xmake的检测机制。&lt;/p&gt;

&lt;h3 id=&quot;创建工程&quot;&gt;创建工程&lt;/h3&gt;

&lt;p&gt;接下来，我们就可以创建一个空工程来快速体验下了，xmake自带了cuda的工程模板，只需要指定对应的语言即可创建cuda项目：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -l cuda &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cu
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认创建的cuda工程，就是一个最简单的基于Cuda的hello world工程，其源码结构如下：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;├── src
│   └── main.cu
└── ke.lua
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而xmake.lua里面的内容我们也可以简单看下：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- define target&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- generate SASS code for SM architecture of current host&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- generate PTX code for the virtual architecture to guarantee compatibility&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;compute_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到，除了最基本的.cu源文件添加，跟其他c/c++项目唯一的区别就是多了个&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cugencodes()&lt;/code&gt;用来设置cuda需要的gencodes，关于这块，下面会详细讲解。&lt;/p&gt;

&lt;h3 id=&quot;编译项目&quot;&gt;编译项目&lt;/h3&gt;

&lt;p&gt;工程创建好后，只需要简单的执行xmake即可完成编译。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;00%]: ccache compiling.release src/main.cu
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;99%]: devlinking.release test_gpucode.cu.o
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;需要注意的是：从v2.2.7版本开始，xmake默认构建会启用device-link的构建行为，也就是说，现在编译过程中，会额外增加一步device-link过程：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: devlinking.release test_gpucode.cu.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;按照官方的说法，启用device-link设备代码链接的主要优点是可以为您的应用程序提供更传统的代码结构，尤其是在C++中，在现有项目结构不变的前提下，控制每个构建和链接步骤，方便快速的启用GPU代码，实现混合编译。&lt;/p&gt;

&lt;p&gt;关于这块可参看NVIDIA的官方描述：&lt;a href=&quot;https://devblogs.nvidia.com/separate-compilation-linking-cuda-device-code/&quot;&gt;Separate Compilation and Linking of CUDA C++ Device Code&lt;/a&gt;）
如果要禁用device-link的构建逻辑，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_values(&quot;cuda.devlink&quot;, false)&lt;/code&gt; 来设置禁用它。&lt;/p&gt;

&lt;p&gt;当然，我们也可以尝试直接运行这个cuda程序：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;项目设置&quot;&gt;项目设置&lt;/h3&gt;

&lt;p&gt;并且如果设置了里面值为native，那么xmake会自动探测当前主机的cuda设备对应的gencode。&lt;/p&gt;

&lt;h4 id=&quot;add_cuflags&quot;&gt;add_cuflags&lt;/h4&gt;

&lt;p&gt;这个接口主要用于添加cu代码相关的编译选项，我们如果还需要一些更加定制化的设置flags，那么就可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cuflags&lt;/code&gt;来直接设置更加原始的编译选项，就好比c/c++中的&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxflags&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cuflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-gencode arch=compute_30,code=sm_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;add_culdflags&quot;&gt;add_culdflags&lt;/h4&gt;

&lt;p&gt;这个接口主要用于添加cuda设备链接选项，由于上文所说，2.2.7之后，xmake对于cuda程序的默认构建行为会使用device-link，这个阶段如果要设置一些链接flags，则可以通过这个接口来设置。
因为最终的程序链接，会使用ldflags，不会调用nvcc，直接通过gcc/clang等c/c++链接器来链接，所以device-link这个独立的链接阶段的flags设置，通过这个接口来完成。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_culdflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-gencode arch=compute_30,code=sm_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;add_cugencodes&quot;&gt;add_cugencodes&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cugencodes()&lt;/code&gt;接口其实就是对&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cuflags(&quot;-gencode arch=compute_xx,code=compute_xx&quot;)&lt;/code&gt;编译flags设置的简化封装，其内部参数值对应的实际flags映射关系如下：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compute_xx&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;--&amp;gt; `-gencode arch=compute_xx,code=compute_xx`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sm_xx&lt;/span&gt;                        &lt;span class=&quot;c1&quot;&gt;--&amp;gt; `-gencode arch=compute_xx,code=sm_xx`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;sm_xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sm_yy&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;--&amp;gt; `-gencode arch=compute_xx,code=[sm_xx,sm_yy]`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compute_xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sm_yy&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;--&amp;gt; `-gencode arch=compute_xx,code=sm_yy`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;compute_xx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sm_yy&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sm_zz&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;--&amp;gt; `-gencode arch=compute_xx,code=[sm_yy,sm_zz]`&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;native&lt;/span&gt;                       &lt;span class=&quot;c1&quot;&gt;--&amp;gt; match the fastest cuda device on current host,&lt;/span&gt;
                                   &lt;span class=&quot;n&quot;&gt;eg&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Tesla&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;P100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gencode&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;arch&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;compute_60&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;code&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sm_60&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                                   &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;available&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;no&lt;/span&gt; &lt;span class=&quot;err&quot;&gt;`&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;gencode&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;`&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flags&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;will&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;be&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;added&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sm_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就等价为&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cuflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-gencode arch=compute_30,code=sm_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_culdflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-gencode arch=compute_30,code=sm_30&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是上面的更加精简些，这其实就是个用于简化设置的辅助接口。&lt;/p&gt;

&lt;p&gt;而如果我们设置了native值，那么xmake会自动探测当前主机的cuda设备，然后快速匹配到它对应的gencode设置，自动追加到整个构建过程中。&lt;/p&gt;

&lt;p&gt;例如，如果我们主机目前的GPU是Tesla P100，并且能够被xmake自动检测到，那么下面的设置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;等价于：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;sm_60&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;cudacc的混合编译&quot;&gt;Cuda/C/C++的混合编译&lt;/h3&gt;

&lt;p&gt;对于混合编译，我们只需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;接口继续加上对应的c/c++代码文件就行了，是不是很简单？&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cu&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cugencodes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;native&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;编译设置&quot;&gt;编译设置&lt;/h3&gt;

&lt;p&gt;nvcc在编译内部的c/c++代码时候，其实会调用主机环境的c/c++编译器来编译，比如linux下会默认使用gcc/g++，macos下默认使用clang/clang++，windows上默认使用cl.exe。
如果想要让nvcc采用其他的编译器，比如在linux下改用clang作为默认的c/c++编译器，则需要指定&lt;code class=&quot;highlighter-rouge&quot;&gt;--ccbin=&lt;/code&gt;参数设置，这块可以看下：&lt;a href=&quot;https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html#file-and-path-specifications-compiler-bindir&quot;&gt;compiler-ccbin&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;而在xmake中，也对其进行了支持，只需要设置&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --cu-ccbin=clang&lt;/code&gt; 就可以切换到其他编译器。&lt;/p&gt;

&lt;p&gt;还有两个跟cuda相关的编译参数，我就简单介绍下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;xmake f --cu&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;nvcc --cu-ld&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;nvcc
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;--cu&lt;/code&gt;用来设置.cu代码的编译器，默认就是nvcc，不过clang现在也支持对.cu代码的编译，可以切换设置来尝试，&lt;code class=&quot;highlighter-rouge&quot;&gt;--cu-ld&lt;/code&gt;是设置device-link的链接器，而最终的整体程序link过程，还是用的&lt;code class=&quot;highlighter-rouge&quot;&gt;--ld&lt;/code&gt;来链接的。&lt;/p&gt;
</description>
        <pubDate>Sat, 30 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/30/quickstart-7-build-cuda-project/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/30/quickstart-7-build-cuda-project/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>cuda</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通6：开发和构建Qt程序</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;xmake完全支持对Qt5项目的维护和构建，通过本文将会带你了解如何通过xmake来维护各种类型的Qt项目。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它有自己的IDE程序：qt creator，也有自己的构建程序：qmake，似乎新版本开始打算全面切到cmake来维护了。&lt;/p&gt;

&lt;p&gt;尽管如此，xmake还是对Qt的开发做了支持，搭配上xmake-vscode/xmake-idea等插件，使用户可以在自己熟悉的编辑器和IDE上集成和开发Qt程序，并且在不同平台上提供一致的开发体验。&lt;/p&gt;

&lt;h3 id=&quot;准备构建环境&quot;&gt;准备构建环境&lt;/h3&gt;

&lt;p&gt;首先，我们得准备好Qt开发环境，如果还没安装Qt SDK，那么到qt的官网登录下载安装包：https://www.qt.io/，或者自己拉取qt源码，编译静态版本sdk和工具链。&lt;/p&gt;

&lt;p&gt;通常情况，如果是采用官方提供的QT SDK安装包，并且安装目录采用的默认路径，那么即使不配置QT SDK路径，xmake也会尝试去检测它，一般都是能检测到的，如果检测不到，我们可以尝试手动配置下它：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f --qt&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/xxx/qtsdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者设置到全局路径，避免每次编译切换都要配置一遍：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --qt&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/xxx/qtsdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;创建模板工程&quot;&gt;创建模板工程&lt;/h3&gt;

&lt;p&gt;xmake内置了各种Qt项目的空工程模板，我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;命令来快速创建它们。&lt;/p&gt;

&lt;p&gt;注：由于xmake的master最新版本，也就是还未发布的v2.2.9版本对Qt的模板和构建规则进行了升级，因此本文主要讲解的都是基于最新版本来讲解，
而之前的老模版和规则也是向下兼容的，如果想要继续了解，可以查看相关文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/guide/project_examples?id=qt%e7%a8%8b%e5%ba%8f&quot;&gt;Qt项目开发文档&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建quickapp应用程序&quot;&gt;创建QuickApp应用程序&lt;/h4&gt;

&lt;p&gt;我们先来创建一个带qml的quickapp空工程，只需要敲如下命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.quickapp &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.qml
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cpp
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/qml.qrc
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake会生成带有xmake.lua的Qt项目，xmake.lua内容也很简单：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt.quickapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_headerfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/qml.qrc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了源文件的添加，其他基本上都跟之前的可执行程序项目没什么不同，唯一的区别就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules(&quot;qt.quickapp&quot;)&lt;/code&gt;这个内置的Qt构建规则来代替&lt;code class=&quot;highlighter-rouge&quot;&gt;set_kind(&quot;binary&quot;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;规则内部最终还是设置了binary类型，只不过在此基础上额外增加了一些只有Qt才需要的构建规则，比如：特定links，flags还有includedirs等。&lt;/p&gt;

&lt;p&gt;接下来，我们尝试编译下这个项目：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the architecture ... x86_64
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Xcode directory ... /Applications/Xcode.app
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the SDK version of Xcode ... 10.15
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Qt SDK directory ... /Users/ruki/Qt5.13.2/5.13.2/clang_64
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Qt SDK version ... 5.13.2
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 49%]: compiling.qt.qrc src/qml.qrc
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;*.qrc&lt;/code&gt;文件的构建规则也是在&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;的构建规则里面维护的，所以只有设置了这个rule，才能正常编译qrc文件。&lt;/p&gt;

&lt;p&gt;最后，我们尝试运行下看看：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/guide/qt_quickapp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建widgetapp应用程序&quot;&gt;创建WidgetApp应用程序&lt;/h4&gt;

&lt;p&gt;创建一个widgetapp工程跟上文的quickapp方式基本一致，只需要改下模板名即可：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.widgetapp &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;里面xmake.lua的内容看起来，也仅仅就是把&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;规则改成了&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.widgetapp&lt;/code&gt;规则，另外，ui描述文件从&lt;code class=&quot;highlighter-rouge&quot;&gt;.qrc&lt;/code&gt;变成了&lt;code class=&quot;highlighter-rouge&quot;&gt;.ui&lt;/code&gt;，其他并无区别。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt_widgetapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt.widgetapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/mainwindow.ui&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/mainwindow.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;-- 添加带有 Q_OBJECT 的meta头文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/guide/qt_widgetapp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建静态链接版本应用程序&quot;&gt;创建静态链接版本应用程序&lt;/h4&gt;

&lt;p&gt;默认通过qt官网下载的sdk，都是基于动态库的，如果用户用的是自己拉取qt源码然后编译的static版本qt sdk，那么创建的qt工程类型也必须对应static版本，因为两者来处理链接上会有不同的逻辑。&lt;/p&gt;

&lt;p&gt;对于模板名，后面追加下&lt;code class=&quot;highlighter-rouge&quot;&gt;_static&lt;/code&gt;来创建：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.widgetapp_static &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建的就是基于静态QtSdk的WidgetApp工程，其里面的构建规则，也会改成&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules(&quot;qt.widgetapp_static&quot;)&lt;/code&gt;，其他并无不同，QuickApp项目也是如此。&lt;/p&gt;

&lt;h4 id=&quot;创建其他qt项目&quot;&gt;创建其他Qt项目&lt;/h4&gt;

&lt;p&gt;除了QuickApp和WidgetApp项目，xmake还支持其他Qt项目的创建和编译，比如：终端程序，基于Qt的静态库和动态库等。&lt;/p&gt;

&lt;p&gt;具体的工程模板，我们可以进入help菜单查看里面的模板列表：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create --help
Usage: &lt;span class=&quot;nv&quot;&gt;$xmake&lt;/span&gt; create &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;target]

Create a new project.

Options: 
    -t TEMPLATE, --template&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;TEMPLATE       Select the project template id or 
                                           name of the given language. 
                                           &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: console&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                               - console: c++, go, dlang, cuda, 
                                           rust, swift, objc, c, objc++
                                               - qt.console: c++
                                               - qt.quickapp: c++
                                               - qt.quickapp_static: c++
                                               - qt.shared: c++
                                               - qt.static: c++
                                               - qt.widgetapp: c++
                                               - qt.widgetapp_static: c++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多其他Qt项目的使用说明，可以查看xmake的官方文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/guide/project_examples?id=qt%e7%a8%8b%e5%ba%8f&quot;&gt;Qt项目构建文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;运行和断点调试&quot;&gt;运行和断点调试&lt;/h3&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake run -d&lt;/code&gt;命令来加载gdb/lldb调试程序，或者搭配xmake-vscode插件的断点调试支持，来开发和调试Qt程序。
这块可以阅读前文：&lt;a href=&quot;https://tboox.org/cn/2019/11/09/quickstart-3-run-and-debug/&quot;&gt;xmake从入门到精通3：运行和调试目标程序&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，如果是win平台，我们也可以通过生成vs proj，然后通过vs自带的调试功能，进行断点调试，更加方便：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vsxmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成基于xmake的vs工程后，打开vs工程，点击调试运行即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/manual/qt_vs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;开发android程序&quot;&gt;开发Android程序&lt;/h3&gt;

&lt;p&gt;xmake目前是完全支持编译Android版本的Qt项目，整个Qt项目包括xmake.lua完全跟前面的例子一致，并不需要做特别的设置。&lt;/p&gt;

&lt;p&gt;我们需要做的仅仅是，切换到android的编译平台去编译它，不过由于要生成apk包，在执行xmake编译后，qt构建规则会自动对android程序做一个部署deploy步骤，也就是调用qt内部的androiddeployqt程序去生成apk包。&lt;/p&gt;

&lt;p&gt;因此除了需要android ndk，我们还需要额外依赖android sdk，通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;--android_sdk&lt;/code&gt;参数对其指定下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/Downloads/android-ndk-r19c/ --android_sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/Library/Android/sdk/ -c 
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: compiling.qt.qrc src/qml.qrc
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 50%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release libappdemo.so
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: generating.qt.app appdemo.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的配置和构建过程就可以很方便的将之前的QuickApp和WidgetApp项目编译成Android App，另外qt规则内部还对android版本定制了install程序，可以很方便的安装qt apk到设备。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake install
installing appdemo ...
installing build/android/armv7-a/release/appdemo.apk ..
success
install ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装和运行后的效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/151335/57430932-c7261000-7263-11e9-8886-eff07208d0d8.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于如何配置Android编译环境，可阅读前文：&lt;a href=&quot;https://tboox.org/cn/2019/11/15/quickstart-5-build-android/&quot;&gt;xmake从入门到精通5：Android平台编译详解&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;编辑器和ide集成&quot;&gt;编辑器和IDE集成&lt;/h3&gt;

&lt;p&gt;xmake也提供了对各大常用编辑器的插件集成支持，配合这些插件，就可以在自己最熟悉的编辑器上开发和构建Qt程序。&lt;/p&gt;

&lt;h4 id=&quot;在vscode上开发和调试qt程序&quot;&gt;在vscode上开发和调试Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-vscode&quot;&gt;xmake-vscode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-vscode/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在sublime-text上开发qt程序&quot;&gt;在Sublime Text上开发Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-sublime&quot;&gt;xmake-sublime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-sublime/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在ideaclionandroid-studio上开发qt程序&quot;&gt;在Idea/CLion/Android Studio上开发Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-idea&quot;&gt;xmake-idea&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-idea/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在visualstudio里面开发和调试qt程序&quot;&gt;在VisualStudio里面开发和调试Qt程序&lt;/h4&gt;

&lt;p&gt;也就是刚上面提到的通过生成vs proj方式来集成xmake：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vsxmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成基于xmake的vs工程后，打开vs工程，点击调试运行即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/manual/qt_vs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这块，具体详情，可以查看插件文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/plugin/builtin_plugins?id=%e7%94%9f%e6%88%90visualstudio%e5%b7%a5%e7%a8%8b&quot;&gt;使用xmake生成vs工程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/21/quickstart-6-build-qt-project/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/21/quickstart-6-build-qt-project/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>qt</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>Xmake Getting Started Tutorial 5: Introduction to Android platform compilation</title>
        <description>&lt;p&gt;xmake is a lightweight and modern c/c++ project building tool based on Lua. It’s main features are: easy to use syntax, easy to use project maintenance, 
and a consistent build experience across platforms.&lt;/p&gt;

&lt;p&gt;This article mainly explains in detail how to compile libraries and executable programs that can run under android through xmake.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;Project Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io&quot;&gt;Official Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ready-to-work&quot;&gt;Ready to work&lt;/h3&gt;

&lt;p&gt;First of all, we need to prepare the ndk toolchain necessary for compiling the android native library. 
If you haven’t, you can download and decompress it from the official websit: &lt;a href=&quot;https://developer.android.com/ndk&quot;&gt;Android NDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;If you want to get better backward compatibility, you can choose the r16 version, because this is the last version that supports armeabi. If there is no special requirement, you can download the latest version directly.&lt;/p&gt;

&lt;h3 id=&quot;ndk-integration-and-compilation&quot;&gt;NDK integration and compilation&lt;/h3&gt;

&lt;h4 id=&quot;manually-configure-the-ndk&quot;&gt;Manually configure the NDK&lt;/h4&gt;

&lt;p&gt;We only need to pass the decompressed ndk directory path to xmake to complete the configuration, and we can compile directly, for example:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/downloads/android-ndk-r19c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Among them, &lt;code class=&quot;highlighter-rouge&quot;&gt;-p android&lt;/code&gt; is used to switch to the android platform, because if you do not specify a platform, the target program of the current host platform will be compiled by default.&lt;/p&gt;

&lt;p&gt;Generally, if there is no special requirement, the above configuration can complete the compilation of the android native program. Currently, xmake has built-in support for the generation of three types of target files: binary, static, and shared, which correspond to executable programs and .a static libraries. .so dynamic library.&lt;/p&gt;

&lt;h4 id=&quot;global-configuration-of-ndk-paths&quot;&gt;Global configuration of NDK paths&lt;/h4&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f/config&lt;/code&gt; command is only for the configuration of the current project. If you often need to set the ndk path again during cross-platform compilation and configuration switching, it is still a little tedious.&lt;/p&gt;

&lt;p&gt;We can set it through the &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake g/global&lt;/code&gt; global configuration command to ensure it takes effect permanently.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/xxx/android-ndk-r19c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We can also ensure the permanent effect by setting the &lt;code class=&quot;highlighter-rouge&quot;&gt;ANDROID_NDK_HOME&lt;/code&gt; global environment variable, which is similar to the effect of the above command configuration.&lt;/p&gt;

&lt;h4 id=&quot;automatic-detection-of-ndk-paths&quot;&gt;Automatic detection of NDK paths&lt;/h4&gt;

&lt;p&gt;Generally, even if the ndk path is not configured, xmake will still try to detect some common paths by default. For example, under macos, it will automatically detect whether the following paths exist:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Library/Android/sdk/ndk-bundle
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is the SDK directory automatically created by android studio after downloading the Mac, and the common place for the ndk.&lt;/p&gt;

&lt;p&gt;Or try to probe from the environment variable &lt;code class=&quot;highlighter-rouge&quot;&gt;ANDROID_NDK_HOME&lt;/code&gt;, if it exists.&lt;/p&gt;

&lt;p&gt;If it can be detected, there is no need to configure it manually.&lt;/p&gt;

&lt;h3 id=&quot;c-stl-library-configuration-switch&quot;&gt;C++ STL library configuration switch&lt;/h3&gt;

&lt;p&gt;First, let’s introduce the three stl library versions provided by ndk.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;stlport: the stl library built in early ndk, now basically obsolete&lt;/li&gt;
  &lt;li&gt;gnustl: stl library mainly used before ndk r16b, but since r16b, it has also been removed by google&lt;/li&gt;
  &lt;li&gt;llvm-c++: newer ndk built-in stl libraries after r16b&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Therefore, when we compile the android library, we need to choose stl and choose the appropriate ndk version according to our needs. Xmake usually uses the llvm-c++ library by default if possible. If it finds that the current ndk version is older, it will try to degrade Go to gnustl.&lt;/p&gt;

&lt;p&gt;Users can also manually modify the version of the stl library, for example:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Specifically, for the configuration value of the ndk_cxxstl option, you can type help to view, &lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --help&lt;/code&gt;, mainly:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_shared&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api-version-settings&quot;&gt;API Version Settings&lt;/h3&gt;

&lt;p&gt;If during the compilation process, some libc library symbols are not found, it is usually possible that the api version is not set correctly, because some libc functions exist only in higher version apis.&lt;/p&gt;

&lt;p&gt;At this time, we can solve it by trying to manually modify the api version:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;switch-compilation-architecture&quot;&gt;Switch compilation architecture&lt;/h3&gt;

&lt;p&gt;At present xmake provides configuration of these architectures &lt;code class=&quot;highlighter-rouge&quot;&gt;armv7-a&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt; arm64-v8a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;armv5te&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt; mips&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mips64&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt; i386&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64&lt;/code&gt;. If arch is not specified, then armv7 will be used by default. Architecture.&lt;/p&gt;

&lt;p&gt;Manually modify the arch as follows:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx -a arm64-v8a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;android-related-configuration-settings&quot;&gt;Android related configuration settings&lt;/h3&gt;

&lt;p&gt;If the project needs to configure some compilation settings unique to the android platform, such as adding specific macro switches, link libraries, etc., you can use &lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat(&quot;android&quot;)&lt;/code&gt; to determine the processing in xmake.lua.&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*. c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;android&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ANDROID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;        &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;add_syslinks&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;err&quot;&gt;    &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;

&lt;h4 id=&quot;what-should-i-do-if-i-cannot-find-some-libcstl-library-header-files&quot;&gt;What should I do if I cannot find some libc/stl library header files?&lt;/h4&gt;

&lt;p&gt;You can try to modify the stl library version and api version to solve it. For example, ndk r16b recommends using the gnustl library, because this version of the llvmc++ library has just been integrated shortly, there are many problems, and it is easy to encounter various compilation problems during use.&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;the-compiled-executable-does-not-run-on-the-device&quot;&gt;The compiled executable does not run on the device?&lt;/h4&gt;

&lt;p&gt;Usually the api version is set too high, causing incompatibility issues, you can try to reduce the api version.&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/2019/11/15/quickstart-5-build-android/</link>
        <guid isPermaLink="true">http://www.tboox.org/2019/11/15/quickstart-5-build-android/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>android</category>
        
        <category>jni</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通5：Android平台编译详解</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解如何通过xmake编译可在android下运行的库和可执行程序。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;首先，我们需要先准备好编译android native库必须的ndk工具链，如果还没有可以从官网下载解压即可：&lt;a href=&quot;https://developer.android.com/ndk/&quot;&gt;Android NDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是为了获取更好的向下兼容性，可以选择r16版本，因为这个是最后一个支持armeabi的版本，如果没什么特别需求，可以直接下载最新版。&lt;/p&gt;

&lt;h3 id=&quot;ndk集成和编译&quot;&gt;NDK集成和编译&lt;/h3&gt;

&lt;h4 id=&quot;手动配置ndk&quot;&gt;手动配置NDK&lt;/h4&gt;

&lt;p&gt;我们只需要将解压后ndk目录路径传递给xmake完成配置，可以直接编译了，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/downloads/android-ndk-r19c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-p android&lt;/code&gt;用于切换到android平台，因为如果不指定平台，默认会编译当前主机平台的target程序。&lt;/p&gt;

&lt;p&gt;通常，如果没特殊需求，上面的配置就可以完成android native程序的编译，目前xmake内置支持：binary, static, shared这三种基础target类型文件的生成，分别对应可执行程序，.a静态库，.so动态库。&lt;/p&gt;

&lt;h4 id=&quot;ndk路径的全局配置&quot;&gt;NDK路径的全局配置&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f/config&lt;/code&gt;命令仅仅是针对当前项目的配置，如果经常跨平台编译和配置切换都要重新设置一遍ndk路径，那么还是稍显繁琐。&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake g/global&lt;/code&gt;全局配置命令来设置它，确保永久生效。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/xxx/android-ndk-r19c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;ANDROID_NDK_HOME&lt;/code&gt;全局环境变量来确保永久生效，这跟上述命令配置的效果是差不多的。&lt;/p&gt;

&lt;h4 id=&quot;ndk路径的自动探测&quot;&gt;NDK路径的自动探测&lt;/h4&gt;

&lt;p&gt;通常情况下即使没有配置ndk路径，xmake还是会尝试默认检测一些常用路径，比如在macos下会自动探测是否存在以下路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Library/Android/sdk/ndk-bundle
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是mac下装完android studio自动创建的sdk目录，以及ndk的常用放置路径。&lt;/p&gt;

&lt;p&gt;或者尝试从ANDROID_NDK_HOME这种环境变量中探测，如果存在的话。&lt;/p&gt;

&lt;p&gt;如果能探测到，也就没必要再额外手动配置了。&lt;/p&gt;

&lt;h3 id=&quot;c-stl库配置切换&quot;&gt;C++ STL库配置切换&lt;/h3&gt;

&lt;p&gt;首先，我们先来介绍下，ndk提供的三种stl库版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;stlport：早期ndk内置的stl库，现在基本已废弃&lt;/li&gt;
  &lt;li&gt;gnustl：ndk r16b之前主要使用的stl库，但是自从r16b之后，也已经被google去掉了&lt;/li&gt;
  &lt;li&gt;llvm-c++：r16b之后较新的ndk内置的stl库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，我们在编译android库的时候，需要根据自己的需求，选用stl，以及选用合适的ndk版本，而xmake通常会尽可能默认使用llvm-c++库，如果发现当前ndk版本比较老，会尝试退化到gnustl上去。&lt;/p&gt;

&lt;p&gt;用户也可以手动修改stl库的版本，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体，关于ndk_cxxstl选项的配置值，可以敲help查看，&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --help&lt;/code&gt;，主要就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_shared&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api版本设置&quot;&gt;API版本设置&lt;/h3&gt;

&lt;p&gt;如果在编译过程中，报出一些libc库符号找不到，通常有可能是api版本没设置对，因为有些libc函数，只有在高版本api下才存在。&lt;/p&gt;

&lt;p&gt;这个时候，我们可以通过尝试手动修改api版本来解决：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;arch的编译切换&quot;&gt;arch的编译切换&lt;/h3&gt;

&lt;p&gt;目前xmake提供 &lt;code class=&quot;highlighter-rouge&quot;&gt;armv7-a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;arm64-v8a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;armv5te&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mips&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mips64&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i386&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64&lt;/code&gt;这些架构的配置编译，如果没有指定arch，那么默认会使用armv7架构。&lt;/p&gt;

&lt;p&gt;手动修改arch方式如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx -a arm64-v8a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;android相关配置设置&quot;&gt;Android相关配置设置&lt;/h3&gt;

&lt;p&gt;如果项目中需要配置一些只有android平台才有的编译设置，比如添加特定宏开关，链接库等，可以在xmake.lua中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat(&quot;android&quot;)&lt;/code&gt;来判断处理。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;android&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ANDROID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_syslinks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;

&lt;h4 id=&quot;遇到一些libcstl库头文件找不到怎么办&quot;&gt;遇到一些libc/stl库头文件找不到怎么办？&lt;/h4&gt;

&lt;p&gt;可以尝试修改stl库版本，和api版本来解决，比如ndk r16b 推荐使用gnustl库，因为这个版本的llvmc++库刚集成进去不久，问题比较多，使用过程中容易遇到各种编译问题。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;编译生成的可执行程序在设备上运行不起来&quot;&gt;编译生成的可执行程序在设备上运行不起来？&lt;/h4&gt;

&lt;p&gt;通常是api版本设置太高，导致的不兼容问题，可以尝试调低api版本。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/15/quickstart-5-build-android/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/15/quickstart-5-build-android/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>android</category>
        
        <category>jni</category>
        
        
        <category>xmake</category>
        
      </item>
    
  </channel>
</rss>
