<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TBOOX Open Source Project</title>
    <description>Focus on cross-platform development using c language</description>
    <link>http://www.tboox.org/</link>
    <atom:link href="http://www.tboox.org/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 21 Nov 2019 18:36:14 +0800</pubDate>
    <lastBuildDate>Thu, 21 Nov 2019 18:36:14 +0800</lastBuildDate>
    <generator>Jekyll v3.1.0</generator>
    
      <item>
        <title>xmake从入门到精通6：开发和构建Qt程序</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;xmake完全支持对Qt5项目的维护和构建，通过本文将会带你了解如何通过xmake来维护各种类型的Qt项目。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;前言&quot;&gt;前言&lt;/h3&gt;

&lt;p&gt;Qt是一个1991年由Qt Company开发的跨平台C++图形用户界面应用程序开发框架。它有自己的IDE程序：qt creator，也有自己的构建程序：qmake，似乎新版本开始打算全面切到cmake来维护了。&lt;/p&gt;

&lt;p&gt;尽管如此，xmake还是对Qt的开发做了支持，搭配上xmake-vscode/xmake-idea等插件，使用户可以在自己熟悉的编辑器和IDE上集成和开发Qt程序，并且在不同平台上提供一致的开发体验。&lt;/p&gt;

&lt;h3 id=&quot;准备构建环境&quot;&gt;准备构建环境&lt;/h3&gt;

&lt;p&gt;首先，我们得准备好Qt开发环境，如果还没安装Qt SDK，那么到qt的官网登录下载安装包：https://www.qt.io/，或者自己拉取qt源码，编译静态版本sdk和工具链。&lt;/p&gt;

&lt;p&gt;通常情况，如果是采用官方提供的QT SDK安装包，并且安装目录采用的默认路径，那么即使不配置QT SDK路径，xmake也会尝试去检测它，一般都是能检测到的，如果检测不到，我们可以尝试手动配置下它：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f --qt&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/xxx/qtsdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者设置到全局路径，避免每次编译切换都要配置一遍：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --qt&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/home/xxx/qtsdk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;创建模板工程&quot;&gt;创建模板工程&lt;/h3&gt;

&lt;p&gt;xmake内置了各种Qt项目的空工程模板，我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;命令来快速创建它们。&lt;/p&gt;

&lt;p&gt;注：由于xmake的master最新版本，也就是还未发布的v2.2.9版本对Qt的模板和构建规则进行了升级，因此本文主要讲解的都是基于最新版本来讲解，
而之前的老模版和规则也是向下兼容的，如果想要继续了解，可以查看相关文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/guide/project_examples?id=qt%e7%a8%8b%e5%ba%8f&quot;&gt;Qt项目开发文档&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建quickapp应用程序&quot;&gt;创建QuickApp应用程序&lt;/h4&gt;

&lt;p&gt;我们先来创建一个带qml的quickapp空工程，只需要敲如下命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.quickapp &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.qml
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cpp
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/qml.qrc
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake会生成带有xmake.lua的Qt项目，xmake.lua内容也很简单：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt.quickapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_headerfiles&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/qml.qrc&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了源文件的添加，其他基本上都跟之前的可执行程序项目没什么不同，唯一的区别就是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules(&quot;qt.quickapp&quot;)&lt;/code&gt;这个内置的Qt构建规则来代替&lt;code class=&quot;highlighter-rouge&quot;&gt;set_kind(&quot;binary&quot;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;其实&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;规则内部最终还是设置了binary类型，只不过在此基础上额外增加了一些只有Qt才需要的构建规则，比如：特定links，flags还有includedirs等。&lt;/p&gt;

&lt;p&gt;接下来，我们尝试编译下这个项目：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the architecture ... x86_64
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Xcode directory ... /Applications/Xcode.app
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the SDK version of Xcode ... 10.15
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Qt SDK directory ... /Users/ruki/Qt5.13.2/5.13.2/clang_64
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Qt SDK version ... 5.13.2
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 49%]: compiling.qt.qrc src/qml.qrc
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中&lt;code class=&quot;highlighter-rouge&quot;&gt;*.qrc&lt;/code&gt;文件的构建规则也是在&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;的构建规则里面维护的，所以只有设置了这个rule，才能正常编译qrc文件。&lt;/p&gt;

&lt;p&gt;最后，我们尝试运行下看看：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake run
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/guide/qt_quickapp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建widgetapp应用程序&quot;&gt;创建WidgetApp应用程序&lt;/h4&gt;

&lt;p&gt;创建一个widgetapp工程跟上文的quickapp方式基本一致，只需要改下模板名即可：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.widgetapp &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;里面xmake.lua的内容看起来，也仅仅就是把&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.quickapp&lt;/code&gt;规则改成了&lt;code class=&quot;highlighter-rouge&quot;&gt;qt.widgetapp&lt;/code&gt;规则，另外，ui描述文件从&lt;code class=&quot;highlighter-rouge&quot;&gt;.qrc&lt;/code&gt;变成了&lt;code class=&quot;highlighter-rouge&quot;&gt;.ui&lt;/code&gt;，其他并无区别。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt_widgetapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;qt.widgetapp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/mainwindow.ui&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/mainwindow.h&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;-- 添加带有 Q_OBJECT 的meta头文件&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/guide/qt_widgetapp.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;创建静态链接版本应用程序&quot;&gt;创建静态链接版本应用程序&lt;/h4&gt;

&lt;p&gt;默认通过qt官网下载的sdk，都是基于动态库的，如果用户用的是自己拉取qt源码然后编译的static版本qt sdk，那么创建的qt工程类型也必须对应static版本，因为两者来处理链接上会有不同的逻辑。&lt;/p&gt;

&lt;p&gt;对于模板名，后面追加下&lt;code class=&quot;highlighter-rouge&quot;&gt;_static&lt;/code&gt;来创建：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -t qt.widgetapp_static &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;创建的就是基于静态QtSdk的WidgetApp工程，其里面的构建规则，也会改成&lt;code class=&quot;highlighter-rouge&quot;&gt;add_rules(&quot;qt.widgetapp_static&quot;)&lt;/code&gt;，其他并无不同，QuickApp项目也是如此。&lt;/p&gt;

&lt;h4 id=&quot;创建其他qt项目&quot;&gt;创建其他Qt项目&lt;/h4&gt;

&lt;p&gt;除了QuickApp和WidgetApp项目，xmake还支持其他Qt项目的创建和编译，比如：终端程序，基于Qt的静态库和动态库等。&lt;/p&gt;

&lt;p&gt;具体的工程模板，我们可以进入help菜单查看里面的模板列表：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create --help
Usage: &lt;span class=&quot;nv&quot;&gt;$xmake&lt;/span&gt; create &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;target]

Create a new project.

Options: 
    -t TEMPLATE, --template&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;TEMPLATE       Select the project template id or 
                                           name of the given language. 
                                           &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: console&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                               - console: c++, go, dlang, cuda, 
                                           rust, swift, objc, c, objc++
                                               - qt.console: c++
                                               - qt.quickapp: c++
                                               - qt.quickapp_static: c++
                                               - qt.shared: c++
                                               - qt.static: c++
                                               - qt.widgetapp: c++
                                               - qt.widgetapp_static: c++
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多其他Qt项目的使用说明，可以查看xmake的官方文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/guide/project_examples?id=qt%e7%a8%8b%e5%ba%8f&quot;&gt;Qt项目构建文档&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;运行和断点调试&quot;&gt;运行和断点调试&lt;/h3&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake run -d&lt;/code&gt;命令来加载gdb/lldb调试程序，或者搭配xmake-vscode插件的断点调试支持，来开发和调试Qt程序。
这块可以阅读前文：&lt;a href=&quot;https://tboox.org/cn/2019/11/09/quickstart-3-run-and-debug/&quot;&gt;xmake从入门到精通3：运行和调试目标程序&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;另外，如果是win平台，我们也可以通过生成vs proj，然后通过vs自带的调试功能，进行断点调试，更加方便：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vsxmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成基于xmake的vs工程后，打开vs工程，点击调试运行即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/manual/qt_vs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;开发android程序&quot;&gt;开发Android程序&lt;/h3&gt;

&lt;p&gt;xmake目前是完全支持编译Android版本的Qt项目，整个Qt项目包括xmake.lua完全跟前面的例子一致，并不需要做特别的设置。&lt;/p&gt;

&lt;p&gt;我们需要做的仅仅是，切换到android的编译平台去编译它，比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/xxx/android-ndk-r19c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;就可以很方便的将之前的QuickApp和WidgetApp项目编译成Android App，其运行效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://user-images.githubusercontent.com/151335/57430932-c7261000-7263-11e9-8886-eff07208d0d8.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于如何配置Android编译环境，可阅读前文：&lt;a href=&quot;https://tboox.org/cn/2019/11/15/quickstart-5-build-android/&quot;&gt;xmake从入门到精通5：Android平台编译详解&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;不过由于要生成apk包，在执行xmake编译后，qt构建规则会自动对android程序做一个部署deploy步骤，也就是调用qt内部的androiddeployqt程序去生成apk包。&lt;/p&gt;

&lt;p&gt;这除了需要android ndk，还需要额外依赖android sdk，因此，我们还需要对其指定下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/Downloads/android-ndk-r19c/ --android_sdk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/Library/Android/sdk/ -c 
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: compiling.qt.qrc src/qml.qrc
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt; 50%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release libappdemo.so
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: generating.qt.app appdemo.apk
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且qt规则内部还对android版本定制了install程序，可以很方便的安装qt apk到设备。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake install
installing appdemo ...
installing build/android/armv7-a/release/appdemo.apk ..
success
install ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;编辑器和ide集成&quot;&gt;编辑器和IDE集成&lt;/h3&gt;

&lt;p&gt;xmake也提供了对各大常用编辑器的插件集成支持，配合这些插件，就可以在自己最熟悉的编辑器上开发和构建Qt程序。&lt;/p&gt;

&lt;h4 id=&quot;在vscode上开发和调试qt程序&quot;&gt;在vscode上开发和调试Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-vscode&quot;&gt;xmake-vscode&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-vscode/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在sublime-text上开发qt程序&quot;&gt;在Sublime Text上开发Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-sublime&quot;&gt;xmake-sublime&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-sublime/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在ideaclionandroid-studio上开发qt程序&quot;&gt;在Idea/CLion/Android Studio上开发Qt程序&lt;/h4&gt;

&lt;p&gt;插件地址：&lt;a href=&quot;https://github.com/xmake-io/xmake-idea&quot;&gt;xmake-idea&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/tboox/xmake-idea/master/res/problem.gif&quot; width=&quot;650px&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;在visualstudio里面开发和调试qt程序&quot;&gt;在VisualStudio里面开发和调试Qt程序&lt;/h4&gt;

&lt;p&gt;也就是刚上面提到的通过生成vs proj方式来集成xmake：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake project -k vsxmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;生成基于xmake的vs工程后，打开vs工程，点击调试运行即可：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://xmake.io/assets/img/manual/qt_vs.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这块，具体详情，可以查看插件文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/plugin/builtin_plugins?id=%e7%94%9f%e6%88%90visualstudio%e5%b7%a5%e7%a8%8b&quot;&gt;使用xmake生成vs工程&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Thu, 21 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/21/quickstart-6-build-qt-project/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/21/quickstart-6-build-qt-project/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>qt</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通5：Android平台编译详解</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解如何通过xmake编译可在android下运行的库和可执行程序。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;准备工作&quot;&gt;准备工作&lt;/h3&gt;

&lt;p&gt;首先，我们需要先准备好编译android native库必须的ndk工具链，如果还没有可以从官网下载解压即可：&lt;a href=&quot;https://developer.android.com/ndk/&quot;&gt;Android NDK&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;如果是为了获取更好的向下兼容性，可以选择r16版本，因为这个是最后一个支持armeabi的版本，如果没什么特别需求，可以直接下载最新版。&lt;/p&gt;

&lt;h3 id=&quot;ndk集成和编译&quot;&gt;NDK集成和编译&lt;/h3&gt;

&lt;h4 id=&quot;手动配置ndk&quot;&gt;手动配置NDK&lt;/h4&gt;

&lt;p&gt;我们只需要将解压后ndk目录路径传递给xmake完成配置，可以直接编译了，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/downloads/android-ndk-r19c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;-p android&lt;/code&gt;用于切换到android平台，因为如果不指定平台，默认会编译当前主机平台的target程序。&lt;/p&gt;

&lt;p&gt;通常，如果没特殊需求，上面的配置就可以完成android native程序的编译，目前xmake内置支持：binary, static, shared这三种基础target类型文件的生成，分别对应可执行程序，.a静态库，.so动态库。&lt;/p&gt;

&lt;h4 id=&quot;ndk路径的全局配置&quot;&gt;NDK路径的全局配置&lt;/h4&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f/config&lt;/code&gt;命令仅仅是针对当前项目的配置，如果经常跨平台编译和配置切换都要重新设置一遍ndk路径，那么还是稍显繁琐。&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake g/global&lt;/code&gt;全局配置命令来设置它，确保永久生效。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake g --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~/xxx/android-ndk-r19c
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以通过设置&lt;code class=&quot;highlighter-rouge&quot;&gt;ANDROID_NDK_HOME&lt;/code&gt;全局环境变量来确保永久生效，这跟上述命令配置的效果是差不多的。&lt;/p&gt;

&lt;h4 id=&quot;ndk路径的自动探测&quot;&gt;NDK路径的自动探测&lt;/h4&gt;

&lt;p&gt;通常情况下即使没有配置ndk路径，xmake还是会尝试默认检测一些常用路径，比如在macos下会自动探测是否存在以下路径：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;~/Library/Android/sdk/ndk-bundle
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是mac下装完android studio自动创建的sdk目录，以及ndk的常用放置路径。&lt;/p&gt;

&lt;p&gt;或者尝试从ANDROID_NDK_HOME这种环境变量中探测，如果存在的话。&lt;/p&gt;

&lt;p&gt;如果能探测到，也就没必要再额外手动配置了。&lt;/p&gt;

&lt;h3 id=&quot;c-stl库配置切换&quot;&gt;C++ STL库配置切换&lt;/h3&gt;

&lt;p&gt;首先，我们先来介绍下，ndk提供的三种stl库版本&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;stlport：早期ndk内置的stl库，现在基本已废弃&lt;/li&gt;
  &lt;li&gt;gnustl：ndk r16b之前主要使用的stl库，但是自从r16b之后，也已经被google去掉了&lt;/li&gt;
  &lt;li&gt;llvm-c++：r16b之后较新的ndk内置的stl库&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;因此，我们在编译android库的时候，需要根据自己的需求，选用stl，以及选用合适的ndk版本，而xmake通常会尽可能默认使用llvm-c++库，如果发现当前ndk版本比较老，会尝试退化到gnustl上去。&lt;/p&gt;

&lt;p&gt;用户也可以手动修改stl库的版本，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;具体，关于ndk_cxxstl选项的配置值，可以敲help查看，&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f --help&lt;/code&gt;，主要就是：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;llvmstl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;gnustl_shared&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_static&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;stlport_shared&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;api版本设置&quot;&gt;API版本设置&lt;/h3&gt;

&lt;p&gt;如果在编译过程中，报出一些libc库符号找不到，通常有可能是api版本没设置对，因为有些libc函数，只有在高版本api下才存在。&lt;/p&gt;

&lt;p&gt;这个时候，我们可以通过尝试手动修改api版本来解决：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;arch的编译切换&quot;&gt;arch的编译切换&lt;/h3&gt;

&lt;p&gt;目前xmake提供 &lt;code class=&quot;highlighter-rouge&quot;&gt;armv7-a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;arm64-v8a&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;armv5te&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mips&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;mips64&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;i386&lt;/code&gt;,&lt;code class=&quot;highlighter-rouge&quot;&gt;x86_64&lt;/code&gt;这些架构的配置编译，如果没有指定arch，那么默认会使用armv7架构。&lt;/p&gt;

&lt;p&gt;手动修改arch方式如下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxx -a arm64-v8a
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;android相关配置设置&quot;&gt;Android相关配置设置&lt;/h3&gt;

&lt;p&gt;如果项目中需要配置一些只有android平台才有的编译设置，比如添加特定宏开关，链接库等，可以在xmake.lua中，通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat(&quot;android&quot;)&lt;/code&gt;来判断处理。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;android&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ANDROID&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_syslinks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;log&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;faq&quot;&gt;FAQ&lt;/h3&gt;

&lt;h4 id=&quot;遇到一些libcstl库头文件找不到怎么办&quot;&gt;遇到一些libc/stl库头文件找不到怎么办？&lt;/h4&gt;

&lt;p&gt;可以尝试修改stl库版本，和api版本来解决，比如ndk r16b 推荐使用gnustl库，因为这个版本的llvmc++库刚集成进去不久，问题比较多，使用过程中容易遇到各种编译问题。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -p android --ndk&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;xxxx --ndk_cxxstl&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gnustl_shared --ndk_sdkver&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;16
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;编译生成的可执行程序在设备上运行不起来&quot;&gt;编译生成的可执行程序在设备上运行不起来？&lt;/h4&gt;

&lt;p&gt;通常是api版本设置太高，导致的不兼容问题，可以尝试调低api版本。&lt;/p&gt;
</description>
        <pubDate>Fri, 15 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/15/quickstart-5-build-android/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/15/quickstart-5-build-android/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>android</category>
        
        <category>jni</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通4：常用C/C++项目描述设置详解</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解如何编写一些常用的基础xmake.lua描述配置，来实现一些简单的C/C++项目构建管理。
对于大部分小项目，这些配置已经完全足够使用，本系列后期进阶教程中，我会深入详细讲解如果使用一些高级特性来更加灵活定制化地配置项目。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;先来一段最简短的&quot;&gt;先来一段最简短的&lt;/h3&gt;

&lt;p&gt;一行描述即可编译src目录下所有c源文件，然后生成一个名为demo的可执行文件。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;kind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;files&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的写法是精简写法，通常我们更推荐使用下面展开式写法：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这两者完全等价，如果配置很简短，可以完全精简成一行，而拆分成多行更加方便灵活配置。&lt;/p&gt;

&lt;p&gt;如果没有特殊目的，下文我们都会采用第二段的写法。&lt;/p&gt;

&lt;h3 id=&quot;配置项目目标类型&quot;&gt;配置项目目标类型&lt;/h3&gt;

&lt;p&gt;通常的C/C++项目生成的目标文件主要有三大类：可执行程序，静态库，动态库。&lt;/p&gt;

&lt;p&gt;我们可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;set_kind()&lt;/code&gt;配置来设置，分别对应：binary, static, shared&lt;/p&gt;

&lt;p&gt;例如，我们想要编译动态库，只需要修改kind：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;添加宏定义&quot;&gt;添加宏定义&lt;/h3&gt;

&lt;p&gt;编译宏的设置，大多数c/c++项目都会用到，一般如果我们设置编译flags传给gcc/clang，都是要配置：&lt;code class=&quot;highlighter-rouge&quot;&gt;-DXXX&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;而在xmake里面，提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;add_defines()&lt;/code&gt;内置接口来配置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;XXX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;条件配置&quot;&gt;条件配置&lt;/h3&gt;

&lt;p&gt;那如果我们想在不同编译平台，分别设置不同的宏开关呢？我们可以利用lua内置的if语句很方便的实现：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;demo&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;XXX&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;linux&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;macosx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;YYY&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;is_plat()&lt;/code&gt;判断，如果当前编译目标平台是linux或者macosx，那么target会额外增加&lt;code class=&quot;highlighter-rouge&quot;&gt;-DYYY&lt;/code&gt;宏定义。&lt;/p&gt;

&lt;h3 id=&quot;全局配置&quot;&gt;全局配置&lt;/h3&gt;

&lt;p&gt;我们在&lt;code class=&quot;highlighter-rouge&quot;&gt;target(&quot;demo&quot;)&lt;/code&gt;下面的所有配置，都属于demo这个target子域，并不是全局的，所以你会看到通常配置上都加了缩进，就是为了凸显作用域的影响范围。&lt;/p&gt;

&lt;p&gt;通常如果多个target连续定义，下一个target定义就会自动结束上个target的作用域，每个target的配置完全独立，互不干扰：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，上面的配置两个target，各自拥有自己独立的宏定义：&lt;code class=&quot;highlighter-rouge&quot;&gt;TEST1&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;TEST2&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么，我们要对这两个target，设置共用的宏定义，应该如何配置呢？&lt;/p&gt;

&lt;p&gt;每个target下面都配置一遍&lt;code class=&quot;highlighter-rouge&quot;&gt;add_defines(&quot;TEST&quot;)&lt;/code&gt;? 当然可以，不过这样就有点冗余了，配置多了就会很难维护，其实我们只需要放置到全局根作用域就行了：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 全局设置&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_arch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;arm64&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;armv7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在target的外层的所有配置都属于全局配置，我们也可以调用&lt;code class=&quot;highlighter-rouge&quot;&gt;target_end()&lt;/code&gt;强制结束target子域，切回全局作用域：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 全局设置&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_arch&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;arm64&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;armv7&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ARM&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;shared&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target_end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;添加编译选项&quot;&gt;添加编译选项&lt;/h3&gt;

&lt;p&gt;如果有些编译选项，xmake没有提供内置api设置，那么我们可以退化到&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cflags&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxflags&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxxflags&lt;/code&gt;来设置，
不过这就需要用户自己去判断编译平台了，因为并不是所有编译flags每个平台都支持。&lt;/p&gt;

&lt;p&gt;比如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-g&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-O2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-DDEBUG&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;windows&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_cflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/MT&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;所有选项值都基于gcc的定义为标准，如果其他编译器不兼容（例如：vc），xmake会自动内部将其转换成对应编译器支持的选项值。 
用户无需操心其兼容性，如果其他编译器没有对应的匹配值，那么xmake会自动忽略器设置。&lt;/p&gt;

&lt;p&gt;我们也可以通过force参数来强制禁用flags的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_cflags&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-g&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-O2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;那如何知道，哪些flags检测失败给忽略了呢，带&lt;code class=&quot;highlighter-rouge&quot;&gt;-v&lt;/code&gt;编译就可以看到，比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake -v
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the /usr/bin/xcrun -sdk macosx clang ... ok
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the flags &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-Oz&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ... ok
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the flags &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-Wno-error&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;deprecated-declarations&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ... ok
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the flags &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-fno-strict-aliasing&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ... ok
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the flags &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-Wno-error&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;expansion-to-defined&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; ... no
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后备注下这三个api的区别：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cflags&lt;/code&gt;：仅添加C代码相关编译flags&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxflags&lt;/code&gt;：添加C/C++代码相关编译flags&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_cxxflags&lt;/code&gt;：仅添加C++代码相关编译flags&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;添加库相关设置&quot;&gt;添加库相关设置&lt;/h3&gt;

&lt;p&gt;一个C/C++库的集成使用，通常需要设置头文件搜索目录，链接库名，库搜索目录，比如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pthread&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_includedirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/include&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_linkdirs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/local/lib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通常，为了保证链接库的依赖顺序，系统库链接通常都会比较靠后，我们通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_syslinks()&lt;/code&gt;来专门设置系统库链接，而&lt;code class=&quot;highlighter-rouge&quot;&gt;add_links()&lt;/code&gt;通常用于非系统库链接：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_links&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;A&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;B&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_syslinks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pthread&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的配置，我们添加了两个第三方链接库：A, B，以及系统库pthread，整个完整的链接顺序是：&lt;code class=&quot;highlighter-rouge&quot;&gt;-lA -lB -lpthread&lt;/code&gt;，syslinks会放在最后面。&lt;/p&gt;

&lt;p&gt;如果你不确定实际的链接顺序，我们可以执行&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake -v&lt;/code&gt;编译，查看完整的链接参数命令行。&lt;/p&gt;

&lt;h3 id=&quot;设置语言标准&quot;&gt;设置语言标准&lt;/h3&gt;

&lt;p&gt;c标准和c++标准可同时进行设置，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 设置c代码标准：c99， c++代码标准：c++11&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;set_languages&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;c99&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c++11&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：并不是设置了指定的标准，编译器就一定会按这个标准来编译，毕竟每个编译器支持的力度不一样，但是xmake会尽最大可能的去适配当前编译工具的支持标准。&lt;/p&gt;

&lt;p&gt;例如：windows下vs的编译器并不支持按c99的标准来编译c代码，只能支持到c89，但是xmake为了尽可能的支持它，所以在设置c99的标准后，
xmake会强制按c++代码模式去编译c代码，从一定程度上解决了windows下编译c99的c代码问题。&lt;/p&gt;

&lt;h3 id=&quot;设置编译优化&quot;&gt;设置编译优化&lt;/h3&gt;

&lt;p&gt;xmake提供了几种内置的编译优化配置：none, fast, faster, fastest, smallest, aggressive，来实现各种级别的编译优化。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果用户通过flags来设置，还需额外考虑不同编译器的不同编译选项，xmake对其进行了内部映射处理，极大程度方便用户提供跨平台性。&lt;/p&gt;

&lt;p&gt;如果想查看详细的映射规则，可以到xmake的官方文档进行查看：&lt;a href=&quot;https://xmake.io/#/zh-cn/manual/project_target?id=targetset_optimize&quot;&gt;编译优化设置&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;调试和发布模式&quot;&gt;调试和发布模式&lt;/h3&gt;

&lt;p&gt;即使xmake提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;set_optimize&lt;/code&gt;简化了不同编译器的复杂配置，但是对于不同的编译模式: debug/release，还是要自己做一些繁琐的判断和配置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;none&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_symbols&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hidden&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_strip&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;all&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iphoneos&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;android&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;smallest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些看似常用的设置，如果每个项目都来一遍，那也很繁琐了，导致xmake.lua不够精简可读，因此xmake提供了一些常用内置规则来简化设置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只需这一行即可，效果是完全一致，用户还可以基于此在做一些额外的定制化配置来改写：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_mode&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_optimize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;fastest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;比如我想在release模式下，强制启用fastest编译优化，既然有了模式配置，那我们怎么切换到debug模式编译呢？（默认是release编译）&lt;/p&gt;

&lt;p&gt;答案：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;xmake&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;m&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;xmake&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;添加源文件&quot;&gt;添加源文件&lt;/h3&gt;

&lt;p&gt;最后，我们在介绍下xmake最常用，也最为强大的设置之一，也就是对编译源文件的配置管理：&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files()&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;我们可以用这个接口，添加各类xmake支持的源文件，比如：c/c++, asm, objc, swift, go, dlang等源文件，甚至是：&lt;code class=&quot;highlighter-rouge&quot;&gt;.obj&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;.a/.lib&lt;/code&gt;等二进制对象和库文件。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test_*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/xxx/**.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/asm/*.S&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/objc/**/hello.m&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中通配符&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;表示匹配当前目录下文件，而&lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;则匹配多级目录下的文件。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;的使用其实是相当灵活方便的，其匹配模式借鉴了premake的风格，但是又对其进行了改善和增强。&lt;/p&gt;

&lt;p&gt;使得不仅可以匹配文件，还有可以在添加文件同时，过滤排除指定模式的一批文件。&lt;/p&gt;

&lt;p&gt;例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;-- 递归添加src下的所有c文件，但是不包括src/impl/下的所有c文件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/**.c|impl/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;-- 添加src下的所有cpp文件，但是不包括src/test.cpp、src/hello.cpp以及src下所有带xx_前缀的cpp文件&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp|test.cpp|hello.cpp|xx_*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中分隔符&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;之后的都是需要排除的文件，这些文件也同样支持匹配模式，并且可以同时添加多个过滤模式，只要中间用&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;分割就行了。。&lt;/p&gt;

&lt;p&gt;添加文件的时候支持过滤一些文件的一个好处就是，可以为后续根据不同开关逻辑添加文件提供基础。&lt;/p&gt;

&lt;p&gt;注：为了使得描述上更加的精简，&lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt;之后的过滤描述都是基于起一个模式：&lt;code class=&quot;highlighter-rouge&quot;&gt;src/*.cpp&lt;/code&gt; 中&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;之前的目录为基础的。
所以上面的例子后面过滤的都是在src下的文件，这个是要注意的。&lt;/p&gt;

&lt;p&gt;2.1.6版本之后，对&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;进行了改进，支持基于files更细粒度的编译选项控制，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_defines&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;TEST1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;test2/test2.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;defines&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;TEST2&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;languages&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;c99&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;includedirs&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;.&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cflags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-O0&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以在&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;的最后一个参数，传入一个配置table，去控制指定files的编译选项，里面的配置参数跟target的一致，并且这些文件还会继承target的通用配置&lt;code class=&quot;highlighter-rouge&quot;&gt;-DTEST1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;2.1.9版本之后，支持添加未知的代码文件，通过设置rule自定义规则，实现这些文件的自定义构建，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- ...&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test/*.md&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rule&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;markdown&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;并且在2.1.9版本之后，可以通过force参数来强制禁用cxflags,cflags等编译选项的自动检测，直接传入编译器，哪怕编译器有可能不支持，也会设置：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;force&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cxflags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-DTEST&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mflags&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;-framework xxx&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}})&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;删除指定源文件&quot;&gt;删除指定源文件&lt;/h3&gt;

&lt;p&gt;既然讲到了添加源文件，那么如何删除，我们也顺带着讲下吧，我们只需要通过&lt;code class=&quot;highlighter-rouge&quot;&gt;del_files()&lt;/code&gt;接口，就可以从前面&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;接口添加的文件列表中，删除指定的文件，例如：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;del_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面的例子，可以从&lt;code class=&quot;highlighter-rouge&quot;&gt;src&lt;/code&gt;目录下添加除&lt;code class=&quot;highlighter-rouge&quot;&gt;test.c&lt;/code&gt;以外的所有文件，当然这个也可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files(&quot;src/*.c|test.c&quot;)&lt;/code&gt;来达到相同的目的，但是这种方式更加灵活。&lt;/p&gt;

&lt;p&gt;例如，我们可以条件判断来控制删除哪些文件，并且此接口也支持&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;的匹配模式，过滤模式，进行批量移除。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/**.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;del_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/test*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;del_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/subdir/*.c|xxx.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;is_plat&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;iphoneos&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;then&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;xxx.m&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;通过上面的例子，我们可以看出&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;del_files&lt;/code&gt;是根据调用顺序，进行顺序添加和删除的，并且通过&lt;code class=&quot;highlighter-rouge&quot;&gt;del_files(&quot;src/subdir/*.c|xxx.c&quot;)&lt;/code&gt;删除一批文件，
并且排除&lt;code class=&quot;highlighter-rouge&quot;&gt;src/subdir/xxx.c&lt;/code&gt;（就是说，不删除这个文件）。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/10/quickstart-4-basic-project-settings/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/10/quickstart-4-basic-project-settings/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>c/c++</category>
        
        <category>xmake配置描述</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通3：运行和调试目标程序</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解如何加载运行编译好的目标程序，以及如何去调试。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;运行生成目标&quot;&gt;运行生成目标&lt;/h3&gt;

&lt;p&gt;xmake也提供了run命令，直接运行生成后的可执行文件，用于方便快速的进行测试，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake run
hello xmake!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;添加运行环境变量&quot;&gt;添加运行环境变量&lt;/h4&gt;

&lt;p&gt;我们也可以在xmake.lua中通过&lt;code class=&quot;highlighter-rouge&quot;&gt;add_runenvs&lt;/code&gt;接口来添加设置默认运行target程序的环境变量。&lt;/p&gt;

&lt;p&gt;所以，对于PATH这种，通过此接口追加值是非常方便的，而且此接口支持多值设置，所以通常就是用来设置带有path sep的多值env。。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.c&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_runenvs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;PATH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/tmp/bin&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;xxx/bin&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_runenvs&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;LD_LIBRARY_PATH&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;/tmp/lib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;xxx/lib&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;更多关于此接口的描述，可以看下文档：&lt;a href=&quot;https://xmake.io/#/zh-cn/manual/project_target?id=targetadd_runenvs&quot;&gt;add_runenvs接口文档&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;自定义运行逻辑&quot;&gt;自定义运行逻辑&lt;/h4&gt;

&lt;p&gt;如果单纯的环境设置，以及默认的加载运行规则不满足需求，我们可以通过定制化&lt;code class=&quot;highlighter-rouge&quot;&gt;on_run&lt;/code&gt;脚本，实现更加复杂的运行逻辑：&lt;/p&gt;

&lt;p&gt;例如，运行安装好的apk程序：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- ...&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;-- 设置自定义运行脚本，自动运行安装好的app程序，并且自动获取设备输出信息&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;on_run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;adb shell am start -n com.demo/com.demo.DemoTest&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;os&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;adb logcat&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;调试程序&quot;&gt;调试程序&lt;/h3&gt;

&lt;h4 id=&quot;命令行调试&quot;&gt;命令行调试&lt;/h4&gt;

&lt;p&gt;我们也可以传递&lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt;参数，调用gdb/lldb等调试器程序，加载目标文件进行调试：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake run -d  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake将会使用系统自带的调试器去加载程序运行，目前支持：lldb, gdb, windbg, vsjitdebugger, ollydbg 等各种调试器。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;nv&quot;&gt;$target&lt;/span&gt; create &lt;span class=&quot;s2&quot;&gt;&quot;build/hello&quot;&lt;/span&gt;
Current executable &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;to &lt;span class=&quot;s1&quot;&gt;&#39;build/hello&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;nv&quot;&gt;$b&lt;/span&gt; main
Breakpoint 1: where &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; hello&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;main, address &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 0x0000000100000f50
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;nv&quot;&gt;$r&lt;/span&gt;
Process 7509 launched: &lt;span class=&quot;s1&quot;&gt;&#39;/private/tmp/hello/build/hello&#39;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x86_64&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Process 7509 stopped
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; thread &lt;span class=&quot;c&quot;&gt;#1: tid = 0x435a2, 0x0000000100000f50 hello`main, queue = &#39;com.apple.main-thread&#39;, stop reason = breakpoint 1.1&lt;/span&gt;
    frame &lt;span class=&quot;c&quot;&gt;#0: 0x0000000100000f50 hello`main&lt;/span&gt;
hello&lt;span class=&quot;sb&quot;&gt;`&lt;/span&gt;main:
&lt;span class=&quot;gp&quot;&gt;-&amp;gt;  &lt;/span&gt;0x100000f50 &amp;lt;+0&amp;gt;:  pushq  %rbp
    0x100000f51 &amp;lt;+1&amp;gt;:  movq   %rsp, %rbp
    0x100000f54 &amp;lt;+4&amp;gt;:  leaq   0x2b&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;%rip&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, %rdi          ; &lt;span class=&quot;s2&quot;&gt;&quot;hello world!&quot;&lt;/span&gt;
    0x100000f5b &amp;lt;+11&amp;gt;: callq  0x100000f64               ; symbol stub &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;: puts
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;lldb]&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;使用vscode进行断点调试&quot;&gt;使用vscode进行断点调试&lt;/h4&gt;

&lt;p&gt;我们还可以通过&lt;a href=&quot;https://github.com/xmake-io/xmake-vscode&quot;&gt;xmake-vscode&lt;/a&gt;插件配合vscode来实现对c/c++项目的断点调试支持。&lt;/p&gt;

&lt;p&gt;另外我们还需要依赖vscode的C++插件才能进行调试支持，不过由于开发c/c++程序，这个插件几乎是必需，所以并没有太大问题。&lt;/p&gt;

&lt;p&gt;就算没有安装此插件，xmake-vscode也会加载lldb/gdb/vsjitdebugger等系统调试器，直接加载调试。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/static/img/xmake/xmake-vscode-debug.gif&quot; width=&quot;60%&quot; /&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/09/quickstart-3-run-and-debug/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/09/quickstart-3-run-and-debug/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>c/c++</category>
        
        <category>运行</category>
        
        <category>调试</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通2：创建和编译工程</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解如何创建一个基于xmake的工程以及编译操作。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;创建空工程&quot;&gt;创建空工程&lt;/h3&gt;

&lt;p&gt;xmake提供了&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;命令，可以很方便的快速创建基于c/c++, swift, objc等各种语言的空工程项目，比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cpp
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认会创建一个c++的hello world工程，根目录下会生成一个xmake.lua用于描述项目的构建规则。&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;add_rules&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;mode.debug&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;mode.release&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;test&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这是一个非常简单的xmake.lua描述，&lt;code class=&quot;highlighter-rouge&quot;&gt;target(&quot;test&quot;)&lt;/code&gt;定义了一个子工程模块test，每个target会生成一个对应的目标文件，此处的binary类型，指定创建一个最基础的可执行文件。&lt;/p&gt;

&lt;p&gt;而最上面的&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.debug&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.release&lt;/code&gt;规则设置，是可选设置，但是通常我们都会建议加上，这样默认就可以生效两种常用的构建模式：debug和release&lt;/p&gt;

&lt;h3 id=&quot;执行编译&quot;&gt;执行编译&lt;/h3&gt;

&lt;p&gt;通常我们如果只是编译当前主机环境的可执行文件，只需要执行xmake这个命令就可以了：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Xcode directory ... /Applications/Xcode.app
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the SDK version of Xcode ... 10.15
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: ccache compiling.release src/main.cpp
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;100%]: linking.release &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake默认会检测当前环境已存在的构建环境，比如笔者当前的xcode环境，然后默认采用release模式编译，如果设置了&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.release&lt;/code&gt;规则，那么就会生效。&lt;/p&gt;

&lt;h3 id=&quot;编译模式切换&quot;&gt;编译模式切换&lt;/h3&gt;

&lt;p&gt;而如果我们要切到&lt;code class=&quot;highlighter-rouge&quot;&gt;mode.debug&lt;/code&gt;编译，只需要：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake f -m debug
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其中，&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake f&lt;/code&gt;是&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake config&lt;/code&gt;命令的简写，用来快速的切换配置，如果上手之后，通常采用简写会更加方便，更多命令的简写，都可执行&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake --help&lt;/code&gt;查看。&lt;/p&gt;

&lt;h3 id=&quot;创建其他模板工程&quot;&gt;创建其他模板工程&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create&lt;/code&gt;还可以用来创建各种其他类型的工程项目，我们可以敲&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake create --help&lt;/code&gt;看下：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create --help
Usage: &lt;span class=&quot;nv&quot;&gt;$xmake&lt;/span&gt; create &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;options] &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;target]

Create a new project.

Options: 
                                           
    -l LANGUAGE, --language&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;LANGUAGE       The project language &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: c++&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                               - c++
                                               - go
                                               - dlang
                                               - cuda
                                               - rust
                                               - swift
                                               - objc
                                               - c
                                               - objc++
    -t TEMPLATE, --template&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;TEMPLATE       Select the project template id or name of the given language. 
                                           &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;default: console&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
                                               - console: c++, go, dlang, cuda, rust, swift, objc, c, objc++
                                               - qt.console: c++
                                               - qt.quickapp: c++
                                               - qt.quickapp_static: c++
                                               - qt.shared: c++
                                               - qt.static: c++
                                               - qt.widgetapp: c++
                                               - qt.widgetapp_static: c++
                                               - shared: c++, dlang, cuda, c
                                               - static: c++, go, dlang, cuda, rust, c
                                               - tbox.console: c++, c
                                               - tbox.shared: c++, c
                                               - tbox.static: c++, c
                                           
    target                                 Create the given target.
                                           Uses the project name as target &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;not exists.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从上面的帮助菜单，我们可以大概了解到，可以通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-l/--language&lt;/code&gt;来指定工程语言，而&lt;code class=&quot;highlighter-rouge&quot;&gt;-t/--template&lt;/code&gt;用来指定闯将的工程模板类型。&lt;/p&gt;

&lt;p&gt;比如，我们创建一个基于c的静态库项目：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -l c -t static &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/interface.c
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/interface.h
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/test.c
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cpp
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以创建基于qt的quickapp项目：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -l c++ -t qt.quickapp &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/interface.c
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.qml
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/interface.h
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/test.c
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.cpp
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/qml.qrc
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;除了c/c++项目，xmake还支持其他语言的项目编译，但xmake重点还是在c/c++上，支持其他语言也主要是为了支持跟c/c++进行混合编译，毕竟其他语言向rust什么的官方有提供更好的构建方案。&lt;/p&gt;

&lt;p&gt;不过我们还是可以使用xmake来尝试编译他们：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake create -l rust &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;create &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt; ...
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: xmake.lua
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: src/main.rs
  &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;+]: .gitignore
create ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the architecture ... x86_64
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the Xcode directory ... /Applications/Xcode.app
checking &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;the SDK version of Xcode ... 10.15
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;  0%]: linking.release &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

</description>
        <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/09/quickstart-2-create-and-build-project/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/09/quickstart-2-create-and-build-project/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>c/c++</category>
        
        <category>创建工程</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>xmake从入门到精通1：安装和更新</title>
        <description>&lt;p&gt;xmake是一个基于Lua的轻量级现代化c/c++的项目构建工具，主要特点是：语法简单易上手，提供更加可读的项目维护，实现跨平台行为一致的构建体验。&lt;/p&gt;

&lt;p&gt;本文主要详细讲解xmake在各个平台下的安装过程。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;安装master版本&quot;&gt;安装Master版本&lt;/h2&gt;

&lt;p&gt;通常情况下我们只需要通过一键安装脚本即可完成安装。&lt;/p&gt;

&lt;h3 id=&quot;使用curl&quot;&gt;使用curl&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用wget&quot;&gt;使用wget&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;bash &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wget https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh -O -&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;使用powershell&quot;&gt;使用powershell&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Invoke-Expression &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;Invoke-Webrequest &lt;span class=&quot;s1&quot;&gt;&#39;https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.ps1&#39;&lt;/span&gt; -UseBasicParsing&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.Content
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：如果ps脚本执行提示失败，可以尝试在管理员模式下执行&lt;/p&gt;

&lt;h2 id=&quot;安装windows版本&quot;&gt;安装Windows版本&lt;/h2&gt;

&lt;h3 id=&quot;使用安装包&quot;&gt;使用安装包&lt;/h3&gt;

&lt;p&gt;windows下提供了预制的nsis安装包，我们可直接从github的Releases下载页面下载后，运行安装包即可。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;a href=&quot;https://github.com/xmake-io/xmake/releases&quot;&gt;Releases&lt;/a&gt; 上下载windows安装包&lt;/li&gt;
  &lt;li&gt;运行安装程序 xmake-[version].exe&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;使用scoop&quot;&gt;使用scoop&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;scoop install xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;macos&quot;&gt;MacOS&lt;/h2&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ruby -e &lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;brew install xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;a href=&quot;https://github.com/xmake-io/xmake/releases&quot;&gt;Releases&lt;/a&gt; 上下载pkg安装包&lt;/li&gt;
  &lt;li&gt;双击运行&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;或者安装master版本:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 使用homebrew安装master版本&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;brew install xmake --HEAD

&lt;span class=&quot;c&quot;&gt;# 或者直接调用shell下载安装&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;bash &amp;lt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;curl -fsSL https://raw.githubusercontent.com/tboox/xmake/master/scripts/get.sh&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;linux&quot;&gt;Linux&lt;/h2&gt;

&lt;p&gt;在archlinux上安装：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;yaourt xmake
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者下载deb包来安装：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;从 &lt;a href=&quot;https://github.com/xmake-io/xmake/releases&quot;&gt;Releases&lt;/a&gt; 上下载deb安装包&lt;/li&gt;
  &lt;li&gt;运行: &lt;code class=&quot;highlighter-rouge&quot;&gt;dpkg -i xmake-xxxx.deb&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;termux&quot;&gt;Termux&lt;/h2&gt;

&lt;p&gt;最新版本的xmake已经很好地支持了termux，而我们也通常只需要执行上面的一键安装脚本即可，如果失败，可参考下文自己拉取源码编译安装。&lt;/p&gt;

&lt;h2 id=&quot;源码编译安装&quot;&gt;源码编译安装&lt;/h2&gt;

&lt;h3 id=&quot;安装&quot;&gt;安装&lt;/h3&gt;

&lt;p&gt;注：切记，xmake不建议在root下安装，所以尽量不要在root下拉取源码编译安装！&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone --recursive https://github.com/xmake-io/xmake.git
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ./xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./scripts/get.sh __local__
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; ~/.xmake/profile
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果觉得github的源太慢，可以通过gitee的镜像源拉取：&lt;code class=&quot;highlighter-rouge&quot;&gt;clone --recursive https://gitee.com/tboox/xmake.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;注：由于目前xmake源码通过git submodule维护依赖，所以clone的时候需要加上&lt;code class=&quot;highlighter-rouge&quot;&gt;--recursive&lt;/code&gt;参数同时拉取所有submodules代码，请不要直接下载tar.gz源码，因为github不会自动打包submodules里面的代码。&lt;/p&gt;

&lt;p&gt;如果git clone的时候忘记加&lt;code class=&quot;highlighter-rouge&quot;&gt;--recursive&lt;/code&gt;，那么也可以执行&lt;code class=&quot;highlighter-rouge&quot;&gt;git submodule update --init&lt;/code&gt;来拉取所有submodules，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone https://github.com/xmake-io/xmake.git
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; ./xmake
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git submodule update --init
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./scripts/get.sh __local__
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注：&lt;code class=&quot;highlighter-rouge&quot;&gt;./get.sh __local__&lt;/code&gt;是安装到&lt;code class=&quot;highlighter-rouge&quot;&gt;~/.local/xmake&lt;/code&gt;下，然后通过&lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.xmake/profile&lt;/code&gt;方式来加载的，所以安装完，当前终端如果执行xmake失败，提示找不到，就手动执行下 &lt;code class=&quot;highlighter-rouge&quot;&gt;source ~/.xmake/profile&lt;/code&gt;，而下次打开终端就不需要了。&lt;/p&gt;

&lt;h3 id=&quot;卸载&quot;&gt;卸载&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./scripts/get.sh __uninstall__
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;仅仅更新安装lua脚本&quot;&gt;仅仅更新安装lua脚本&lt;/h3&gt;

&lt;p&gt;这个开发者本地调试xmake源码才需要：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;./scripts/get.sh __local__ __install_only__
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;root下安装&quot;&gt;root下安装&lt;/h3&gt;

&lt;p&gt;xmake不推荐root下安装使用，因为这很不安全，如果用户非要root下装，装完后，如果提示xmake运行不了，请根据提示传递&lt;code class=&quot;highlighter-rouge&quot;&gt;--root&lt;/code&gt;参数，或者设置&lt;code class=&quot;highlighter-rouge&quot;&gt;XMAKE_ROOT=y&lt;/code&gt;环境变量强行启用下，前提是：用户需要随时注意root下误操作系统文件文件的风险。&lt;/p&gt;

&lt;h3 id=&quot;依赖问题&quot;&gt;依赖问题&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;如果遇到readline相关问题，请装下readline-devel或者libreadline-dev依赖，这个是可选的，仅仅&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake lua&lt;/code&gt;命令执行REPL时候才需要。&lt;/li&gt;
  &lt;li&gt;如果想要提速编译，可以装下ccache，xmake会自动检测并使用，这也是可选的。&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;其他安装方式&quot;&gt;其他安装方式&lt;/h2&gt;

&lt;p&gt;注：这种也是源码编译安装，但是安装路径会直接写入&lt;code class=&quot;highlighter-rouge&quot;&gt;/usr/&lt;/code&gt;下，需要root权限，因此除非特殊情况，不推荐这种安装方式，建议采用上文提供的&lt;code class=&quot;highlighter-rouge&quot;&gt;./get.sh __local__&lt;/code&gt;方式来安装，这两种安装方式的安装路径是不同的，不要混用。&lt;/p&gt;

&lt;p&gt;通过make进行编译安装:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;make build; sudo make install
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;安装到其他指定目录:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo make install &lt;span class=&quot;nv&quot;&gt;prefix&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/local
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;卸载:&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;sudo make uninstall
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;更新升级&quot;&gt;更新升级&lt;/h2&gt;

&lt;p&gt;从v2.2.3版本开始，新增了&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake update&lt;/code&gt;命令，来快速进行自我更新和升级，默认是升级到最新版本，当然也可以指定升级或者回退到某个版本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update 2.2.4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们也可以指定更新到master/dev分支版本：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update master
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;从指定git源更新&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update github:xmake-io/xmake#master
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update gitee:tboox/xmake#dev &lt;span class=&quot;c&quot;&gt;# gitee镜像&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果xmake/core没动过，仅仅更新xmake的lua脚本改动，可以加&lt;code class=&quot;highlighter-rouge&quot;&gt;-s/--scriptonly&lt;/code&gt;快速更新lua脚本&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;xmake update -s dev
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后，我们如果要卸载xmake，也是支持的：&lt;code class=&quot;highlighter-rouge&quot;&gt;xmake update --uninstall&lt;/code&gt;&lt;/p&gt;
</description>
        <pubDate>Sat, 09 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/11/09/quickstart-1-installation/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/11/09/quickstart-1-installation/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>安装</category>
        
        <category>更新</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>tbox v1.6.4 update, new c11 style atomic operation!</title>
        <description>&lt;p&gt;This version mainly improves stream/stdio read and write, character set encoding and other operations, and reconstructs the entire atomic operation implementation, adding a c11-style atomic api for finer-grained control.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox&quot;&gt;Github Repo&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tboox.io/#/zh-cn/&quot;&gt;Online documents&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;new-features&quot;&gt;New features&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox/issues/70&quot;&gt;#70&lt;/a&gt;: Add &lt;code class=&quot;highlighter-rouge&quot;&gt;tb_stream_init_from_sock_ref()&lt;/code&gt; to open a given socket as stream&lt;/li&gt;
  &lt;li&gt;Add stdfile api to read/write stdin, stdout and stderr.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox/issues/81&quot;&gt;#81&lt;/a&gt;: Add set/get thread/process cpu affinity&lt;/li&gt;
  &lt;li&gt;Add filelock api&lt;/li&gt;
  &lt;li&gt;Add anonymous and named pipe&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;changes&quot;&gt;Changes&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Optimize queue_buffer module&lt;/li&gt;
  &lt;li&gt;Improve stream interfaces&lt;/li&gt;
  &lt;li&gt;Improve charset encoding and add ANSI support&lt;/li&gt;
  &lt;li&gt;Improve atomic and add c11-like atomic apis&lt;/li&gt;
  &lt;li&gt;Improve spinlock&lt;/li&gt;
  &lt;li&gt;Support to redirect process output to pipe&lt;/li&gt;
  &lt;li&gt;Uses virtual memory for coroutine stack&lt;/li&gt;
  &lt;li&gt;Improve openssl/mbedtls for https&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/2019/10/11/update-v1.6.4/</link>
        <guid isPermaLink="true">http://www.tboox.org/2019/10/11/update-v1.6.4/</guid>
        
        <category>tbox</category>
        
        <category>atomic</category>
        
        <category>charset</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>tbox v1.6.4更新，新增c11风格原子操作</title>
        <description>&lt;p&gt;此版本主要改进stream/stdio读写，字符集编码转换等操作，并重构整个原子操作实现，新增了c11风格atomic api来更细粒度控制。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://tboox.io/#/zh-cn/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;新特性&quot;&gt;新特性&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox/issues/70&quot;&gt;#70&lt;/a&gt;: 添加&lt;code class=&quot;highlighter-rouge&quot;&gt;tb_stream_init_from_sock_ref()&lt;/code&gt;接口去直接打开一个socket作为stream去读取数据。&lt;/li&gt;
  &lt;li&gt;添加stdfile接口去读写stdin, stdout和stderr。&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox/issues/81&quot;&gt;#81&lt;/a&gt;: 添加对进程和线程的cpu亲缘性设置和获取&lt;/li&gt;
  &lt;li&gt;添加filelock文件锁跨平台api接口&lt;/li&gt;
  &lt;li&gt;添加匿名管道，命名管道支持&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;改进&quot;&gt;改进&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;优化queue_buffer模块&lt;/li&gt;
  &lt;li&gt;改进stream接口实现&lt;/li&gt;
  &lt;li&gt;改进字符集编码转换，以及增加对ANSI编码的支持&lt;/li&gt;
  &lt;li&gt;改进原子操作，并增加c11风格原子接口&lt;/li&gt;
  &lt;li&gt;改进spinlock实现&lt;/li&gt;
  &lt;li&gt;新增进程输出重定向到管道&lt;/li&gt;
  &lt;li&gt;针对协程栈使用虚拟内存&lt;/li&gt;
  &lt;li&gt;改进基于openssl/mbedtls的https访问&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;源码&quot;&gt;源码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/tboox/tbox&quot;&gt;Github&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://gitee.com/tboox/tbox&quot;&gt;Gitee&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Fri, 11 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/10/11/update-v1.6.4/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/10/11/update-v1.6.4/</guid>
        
        <category>tbox</category>
        
        <category>稳定性修复</category>
        
        <category>版本更新</category>
        
        <category>原子</category>
        
        <category>字符集编码</category>
        
        
        <category>tbox</category>
        
      </item>
    
      <item>
        <title>Uses xmake to build c++20 modules</title>
        <description>&lt;p&gt;c++ modules have been officially included in the c++20 draft, and msvc and clang have been basically implemented on &lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019 /p1103r3.pdf&quot;&gt;modules-ts&lt;/a&gt; Support, as c++20’s footsteps are getting closer and closer to us, xmake has also begun to support c++modules in advance.&lt;/p&gt;

&lt;p&gt;At present xmake has fully supported the implementation of the modules-ts of msvc/clang. For gcc, since its cxx-modules branch is still under development, it has not officially entered the master. I have read the changelog inside, and the related flags are still in the process. Constantly changing, I feel that it has not stabilized, so I have not supported it yet.&lt;/p&gt;

&lt;p&gt;For more information about xmake’s progress on c++modules: &lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;https://github.com/xmake-io/xmake/pull/569&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;Github Source&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/&quot;&gt;Official Document&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hello-module&quot;&gt;Hello Module&lt;/h3&gt;

&lt;p&gt;I will not talk about the introduction of c++modules. This is mainly about how to build a c++modules project under xmake. Let’s look at a simple example:&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.mpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The above is a description of the xmake.lua that supports building c++modules files, where &lt;code class=&quot;highlighter-rouge&quot;&gt;hello.mpp&lt;/code&gt; is the module file:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Main.cpp is the main program that uses the hello module:&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello module!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we execute xmake to build this program:&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake
[0%]: ccache compiling.release src/hello.mpp
[50%]: ccache compiling.release src/main.cpp
[100%]: linking.release hello
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;xmake will handle all the details logic internally, for developers, just add the module file &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; as the source file.&lt;/p&gt;

&lt;h3 id=&quot;module-interface-file&quot;&gt;Module Interface File&lt;/h3&gt;

&lt;p&gt;The above mentioned &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; is the module interface file name recommended by xmake. In fact, the default suffix names of the compiler files are not uniform. clang is &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;, while msvc is &lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;, which is very unfriendly for writing a unified module project across compilers.
Therefore, reference is made to the recommendation method in &lt;a href=&quot;https://build2.org/doc/modules-cppcon2017.pdf&quot;&gt;build2&lt;/a&gt;, and the unified &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; suffix is used to standardize the command of the module project interface under xmake.&lt;/p&gt;

&lt;p&gt;Of course, this also supports xmake’s recommended naming scheme. For suffixes such as &lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt; and &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;, xmake is also fully compatible and can be added directly to &lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;compile-parameter-processing&quot;&gt;Compile parameter processing&lt;/h3&gt;

&lt;h4 id=&quot;clang&quot;&gt;clang&lt;/h4&gt;

&lt;p&gt;Let’s first look at how to handle module construction under clang. We only need to add -v to execute xmake build, we can see all the details parameters:&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake -v
[0%]: ccache compiling.release src/hello.mpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts --precompile -x c++-module -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 - Mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -o build/.objs/hello/macosx/x86_64/release/ Src/hello.mpp.o.pcm src/hello.mpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 -mmacosx-version-min=10.14 - Isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -o build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o build /.objs/hello/macosx/x86_64/release/src/hello.mpp.o.pcm
[ 50%]: ccache compiling.release src/main.cpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts -fmodule-file=build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o. Pcm -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10 .14.sdk -o build/.objs/hello/macosx/x86_64/release/src/main.cpp.o src/main.cpp
[100%]: linking.release hello
&quot;/usr/bin/xcrun -sdk macosx clang++&quot; -o build/macosx/x86_64/release/hello build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o build/.objs/hello/ Macosx/x86_64/release/src/main.cpp.o -arch x86_64 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14 .sdk -stdlib=libc++ -lz
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We simplify it as follows:&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -c -fmodules-ts --precompile -x c++-module -o hello.mpp.o.pcm src/hello.mpp
clang -c -fmodules-ts -o hello.mpp.o hello.mpp.o.pcm
clang -c -fmodules-ts -fmodule-file=hello.mpp.o.pcm -o main.cpp.o src/main.cpp
clang++ -o hello hello.mpp.o main.cpp.o
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-fmodules-ts&lt;/code&gt; is used to enable the c++-modules module standard, &lt;code class=&quot;highlighter-rouge&quot;&gt;--precompile&lt;/code&gt; is used to precompile the module interface file. Since &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; is not the default module interface file name of the compiler, xmake is added. &lt;code class=&quot;highlighter-rouge&quot;&gt;-x c++-module&lt;/code&gt; to force compilation as a module interface file.&lt;/p&gt;

&lt;p&gt;Compile the &lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt; module interface file, and finally generate the &lt;code class=&quot;highlighter-rouge&quot;&gt;*.pcm&lt;/code&gt; module file and finally tell the clang compiler by &lt;code class=&quot;highlighter-rouge&quot;&gt;-fmodule-file&lt;/code&gt;. We define the hello module in main.cpp where we compile, avoid compiling main. A compiler error undefined by the hello module occurs at .cpp.&lt;/p&gt;

&lt;p&gt;Finally, clang++ links all object files, including the object files generated by hello.mpp, into the target program.&lt;/p&gt;

&lt;h4 id=&quot;msvc&quot;&gt;msvc&lt;/h4&gt;

&lt;p&gt;For the processing under msvc, I will not elaborate, in fact, the whole logic is similar, I will directly paste the execution of the command process:&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Cl.exe -c /experimental:module /module:interface /module:output hello.mpp.obj.pcm /TP -nologo -Fohello.mpp.obj src\\hello.mpp
Cl.exe -c /experimental:module /module:reference hello.mpp.obj.pcm -nologo -Fomain.cpp.obj src\\main.cpp
Link.exe -nologo -dynamicbase -nxcompat -machine:x64 -out:hello.exe hello.mpp.obj main.cpp.obj
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;gcc&quot;&gt;gcc&lt;/h4&gt;

&lt;p&gt;Originally, I wanted to add gcc to it. Later, I found that gcc support for c++modules is still maintained in an independent branch. I have not yet entered the master. If I want to use it, I have to check the cxx-modules branch code separately. To compile a gcc toolchains that supports c++modules.&lt;/p&gt;

&lt;p&gt;And the use of flags inside is often changing, I feel that it has not been completely stabilized, so I am lazy to toss here, when to support the official version of gcc.&lt;/p&gt;

&lt;p&gt;For more information on the implementation of gcc’s modules-ts implementation, please refer to: https://gcc.gnu.org/wiki/cxx-modules&lt;/p&gt;

&lt;h3 id=&quot;other-examples&quot;&gt;Other examples&lt;/h3&gt;

&lt;p&gt;There are also a lot of engineering examples related to c++modules built into the xmake project. Interested students can refer to the following: &lt;a href=&quot;https://github.com/xmake-io/xmake/tree/dev/tests/projects/c%2B%2B/modules&quot;&gt;c++module examples&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/2019/09/22/xmake-c++20-modules/</link>
        <guid isPermaLink="true">http://www.tboox.org/2019/09/22/xmake-c++20-modules/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>c++20</category>
        
        <category>modules-ts</category>
        
        
        <category>xmake</category>
        
      </item>
    
      <item>
        <title>使用xmake构建c++20 modules</title>
        <description>&lt;p&gt;c++ modules已经正式纳入了c++20草案，msvc和clang也已经基本实现了对&lt;a href=&quot;http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1103r3.pdf&quot;&gt;modules-ts&lt;/a&gt;的支持，随着c++20的脚步离我们越来越近，xmake也开始对c++modules提前做好了支持。&lt;/p&gt;

&lt;p&gt;目前xmake已经完全支持了msvc/clang的modules-ts构建实现，而对于gcc，由于它的cxx-modules分支还在开发中，还没有正式进入master，我看了下里面的changelog，相关flags还在不断变动，感觉还没稳定下来，因此这里暂时还没对其进行支持。&lt;/p&gt;

&lt;p&gt;关于xmake对c++modules的相关进展见：&lt;a href=&quot;https://github.com/xmake-io/xmake/pull/569&quot;&gt;https://github.com/xmake-io/xmake/pull/569&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/xmake-io/xmake&quot;&gt;项目源码&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://xmake.io/#/zh/&quot;&gt;官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;hello-module&quot;&gt;Hello Module&lt;/h3&gt;

&lt;p&gt;关于c++modules的相关介绍我就不多说了，这边主要还是介绍下xmake下如何去构建c++modules项目，我们先来看一个简单的例子：&lt;/p&gt;

&lt;div class=&quot;language-lua highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;set_kind&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;binary&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;add_files&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;src/*.cpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;src/*.mpp&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面是一个支持构建c++modules文件的xmake.lua描述，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;hello.mpp&lt;/code&gt;就是模块文件：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;#include &amp;lt;cstdio&amp;gt;
&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;module&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;export&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;而main.cpp是使用了hello模块的主程序：&lt;/p&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;hello&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;say&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;hello module!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;接下来我们执行xmake来构建下这个程序吧：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake 
[  0%]: ccache compiling.release src/hello.mpp
[ 50%]: ccache compiling.release src/main.cpp
[100%]: linking.release hello
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;是不是非常简单，xmake内部会去处理所有细节逻辑，对于开发者而言，仅仅是添加了模块文件&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;作为源文件而已。&lt;/p&gt;

&lt;h3 id=&quot;模块接口文件&quot;&gt;模块接口文件&lt;/h3&gt;

&lt;p&gt;上文所述的&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;是xmake推荐的模块接口文件命名，其实各家编译器对于模块文件的默认后缀名都是不统一的，clang下是&lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;，而msvc下是&lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;，这对于编写跨编译器统一的模块项目是非常不友好的，
因此这里参考了&lt;a href=&quot;https://build2.org/doc/modules-cppcon2017.pdf&quot;&gt;build2&lt;/a&gt;里面的推荐方式，采用统一的&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;后缀，来规范xmake下模块项目接口的命令。&lt;/p&gt;

&lt;p&gt;当然，这也支持xmake推荐命名方式，而对于&lt;code class=&quot;highlighter-rouge&quot;&gt;*.ixx&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;*.cppm&lt;/code&gt;等后缀名，xmake也是完全兼容支持的，也可以直接添加到&lt;code class=&quot;highlighter-rouge&quot;&gt;add_files&lt;/code&gt;中去。&lt;/p&gt;

&lt;h3 id=&quot;编译参数处理&quot;&gt;编译参数处理&lt;/h3&gt;

&lt;h4 id=&quot;clang&quot;&gt;clang&lt;/h4&gt;

&lt;p&gt;我们先来看下clang下，是如何处理modules构建的，我们只需要加上-v来执行xmake构建，就能看到所有的细节参数：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ruki:hello ruki$ xmake -v
[  0%]: ccache compiling.release src/hello.mpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts --precompile -x c++-module -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -o build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o.pcm src/hello.mpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -o build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o.pcm
[ 50%]: ccache compiling.release src/main.cpp
/usr/local/bin/ccache /usr/bin/xcrun -sdk macosx clang -c -fmodules-ts -fmodule-file=build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o.pcm -Qunused-arguments -arch x86_64 -fpascal-strings -fmessage-length=0 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -o build/.objs/hello/macosx/x86_64/release/src/main.cpp.o src/main.cpp
[100%]: linking.release hello
&quot;/usr/bin/xcrun -sdk macosx clang++&quot; -o build/macosx/x86_64/release/hello build/.objs/hello/macosx/x86_64/release/src/hello.mpp.o build/.objs/hello/macosx/x86_64/release/src/main.cpp.o -arch x86_64 -mmacosx-version-min=10.14 -isysroot /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.14.sdk -stdlib=libc++ -lz
build ok!
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;我们简化下就是：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;clang -c -fmodules-ts --precompile -x c++-module -o hello.mpp.o.pcm src/hello.mpp
clang -c -fmodules-ts -o hello.mpp.o hello.mpp.o.pcm
clang -c -fmodules-ts -fmodule-file=hello.mpp.o.pcm -o main.cpp.o src/main.cpp
clang++ -o hello hello.mpp.o main.cpp.o 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-fmodules-ts&lt;/code&gt;用于启用c++-modules模块标准，&lt;code class=&quot;highlighter-rouge&quot;&gt;--precompile&lt;/code&gt;用于预编译模块接口文件，这里由于&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;不是编译器默认的模块接口文件名，因此xmake加上了&lt;code class=&quot;highlighter-rouge&quot;&gt;-x c++-module&lt;/code&gt;来强制作为模块接口文件来编译。&lt;/p&gt;

&lt;p&gt;编译&lt;code class=&quot;highlighter-rouge&quot;&gt;*.mpp&lt;/code&gt;模块接口文件，最后会生成&lt;code class=&quot;highlighter-rouge&quot;&gt;*.pcm&lt;/code&gt;模块文件最终通过&lt;code class=&quot;highlighter-rouge&quot;&gt;-fmodule-file&lt;/code&gt;来告诉clang编译器，我们编译的main.cpp里面hello模块定义在哪里，避免编译main.cpp时候出现hello module未定义的编译器错误。&lt;/p&gt;

&lt;p&gt;最终，clang++将所有对象文件，包括hello.mpp生成的对象文件，全部link进来生成目标程序。&lt;/p&gt;

&lt;h4 id=&quot;msvc&quot;&gt;msvc&lt;/h4&gt;

&lt;p&gt;对于msvc下的处理，我就不细说了，其实整个逻辑是差不多的，我就直接贴下执行的命令过程吧：&lt;/p&gt;

&lt;div class=&quot;language-console highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cl.exe -c /experimental:module /module:interface /module:output hello.mpp.obj.pcm /TP -nologo -Fohello.mpp.obj src\\hello.mpp
cl.exe -c /experimental:module /module:reference hello.mpp.obj.pcm -nologo -Fomain.cpp.obj src\\main.cpp
link.exe -nologo -dynamicbase -nxcompat -machine:x64 -out:hello.exe hello.mpp.obj main.cpp.obj
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;gcc&quot;&gt;gcc&lt;/h4&gt;

&lt;p&gt;原本是想把gcc也支持进来着的，后来发现gcc对于c++modules的支持，还在独立的分支维护，都还没有进入master，如果要使用，还得单独为此checkout cxx-modules分支代码来编译一份支持c++modules的gcc toolchains才行。&lt;/p&gt;

&lt;p&gt;而且里面的flags使用经常在变动，感觉还没有完全稳定下来，因此这里我懒的去折腾了，等什么时候gcc正式版支持了再说吧。&lt;/p&gt;

&lt;p&gt;如果要进一步了解gcc的modules-ts实现进展，请参考：https://gcc.gnu.org/wiki/cxx-modules&lt;/p&gt;

&lt;h3 id=&quot;其他例子&quot;&gt;其他例子&lt;/h3&gt;

&lt;p&gt;xmake项目下还内置了不少跟c++modules相关的工程examples，有兴趣的同学可以参考下：&lt;a href=&quot;https://github.com/xmake-io/xmake/tree/dev/tests/projects/c%2B%2B/modules&quot;&gt;c++module examples&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Sun, 22 Sep 2019 00:00:00 +0800</pubDate>
        <link>http://www.tboox.org/cn/2019/09/22/xmake-c++20-modules/</link>
        <guid isPermaLink="true">http://www.tboox.org/cn/2019/09/22/xmake-c++20-modules/</guid>
        
        <category>xmake</category>
        
        <category>lua</category>
        
        <category>c++20</category>
        
        <category>modules-ts</category>
        
        
        <category>xmake</category>
        
      </item>
    
  </channel>
</rss>
